var e="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof self?self:global;var t={};(function webpackUniversalModuleDefinition(e,n){t=n()})(0,(function(){return function(e){var t={};function __webpack_require__(n){if(t[n])return t[n].exports;var
i=t[n]={i:n,l:false,exports:{}};e[n].call(i.exports,i,i.exports,__webpack_require__);i.l=true;return i.exports}__webpack_require__.m=e;__webpack_require__.c=t;__webpack_require__.d=function(e,t,n){__webpack_require__.o(e,t)||Object.defineProperty(e,t,{enumerable:true,get:n})};__webpack_require__.r=function(e){"undefined"!==typeof
Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"});Object.defineProperty(e,"__esModule",{value:true})};__webpack_require__.t=function(e,t){1&t&&(e=__webpack_require__(e));if(8&t)return e;if(4&t&&"object"===typeof
e&&e&&e.__esModule)return e;var n=Object.create(null);__webpack_require__.r(n);Object.defineProperty(n,"default",{enumerable:true,value:e});if(2&t&&"string"!=typeof e)for(var i in e)__webpack_require__.d(n,i,function(t){return e[t]}.bind(null,i));return
n};__webpack_require__.n=function(e){var t=e&&e.__esModule?function getDefault(){return e.default}:function getModuleExports(){return e};__webpack_require__.d(t,"a",t);return t};__webpack_require__.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)};__webpack_require__.p="";return
__webpack_require__(__webpack_require__.s=21)}([function(t,n){var i={};t.exports=i;(function(){i._nextId=0;i._seed=0;i._nowStartTime=+new Date;i._warnedOnce={};i._decomp=null; /** * Extends the object in the first argument using the object in the second
argument. * @method extend * @param {} obj * @param {boolean} deep * @return {} obj extended */i.extend=function(e,t){var n,o;if("boolean"===typeof t){n=2;o=t}else{n=1;o=true}for(var r=n;r
<arguments.length;r++){var a=arguments[r];if(a)for(var s in a)if(o&&a[s]&&a[s].constructor===Object)if(e[s]&&e[s].constructor!==Object)e[s]=a[s];else{e[s]=e[s]||{};i.extend(e[s],o,a[s])}else
    e[s]=a[s]}return e}; /** * Creates a new clone of the object, if deep is true references will also be cloned. * @method clone * @param {} obj * @param {bool} deep * @return {} obj cloned */i.clone=function(e,t){return i.extend({},t,e)}; /** * Returns
    the list of keys for the given object. * @method keys * @param {} obj * @return {string[]} keys */i.keys=function(e){if(Object.keys)return Object.keys(e);var t=[];for(var n in e)t.push(n);return t}; /** * Returns the list of values for the given object.
    * @method values * @param {} obj * @return {array} Array of the objects property values */i.values=function(e){var t=[];if(Object.keys){var n=Object.keys(e);for(var i=0;i<n.length;i++)t.push(e[n[i]]);return t}for(var o in e)t.push(e[o]);return t}; /**
    * Gets a value from `base` relative to the `path` string. * @method get * @param {} obj The base object * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz' * @param {number} [begin] Path slice begin * @param {number} [end] Path slice
    end * @return {} The object at the given path */i.get=function(e,t,n,i){t=t.split( ".").slice(n,i);for(var o=0;o<t.length;o+=1)e=e[t[o]];return e}; /** * Sets a value on `base` relative to the given `path` string. * @method set * @param {} obj The base
    object * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz' * @param {} val The value to set * @param {number} [begin] Path slice begin * @param {number} [end] Path slice end * @return {} Pass through `val` for chaining */i.set=function(e,t,n,o,r){var
    a=t.split( ".").slice(o,r);i.get(e,t,0,-1)[a[a.length-1]]=n;return n}; /** * Shuffles the given array in-place. * The function uses a seeded random generator. * @method shuffle * @param {array} array * @return {array} array shuffled randomly */i.shuffle=function(e){for(var
    t=e.length-1;t>0;t--){var n=Math.floor(i.random()*(t+1));var o=e[t];e[t]=e[n];e[n]=o}return e}; /** * Randomly chooses a value from a list with equal probability. * The function uses a seeded random generator. * @method choose * @param {array} choices * @return {object}
    A random choice object from the array */i.choose=function(e){return e[Math.floor(i.random()*e.length)]}; /** * Returns true if the object is a HTMLElement, otherwise false. * @method isElement * @param {object} obj * @return {boolean} True if the
    object is a HTMLElement, otherwise false */i.isElement=function(e){return"undefined"!==typeof HTMLElement?e instanceof HTMLElement:!!(e&&e.nodeType&&e.nodeName)}; /** * Returns true if the object is an array. * @method isArray * @param {object} obj
    * @return {boolean} True if the object is an array, otherwise false */i.isArray=function(e){return"[object Array]"===Object.prototype.toString.call(e)}; /** * Returns true if the object is a function. * @method isFunction * @param {object} obj * @return
    {boolean} True if the object is a function, otherwise false */i.isFunction=function(e){return"function"===typeof e}; /** * Returns true if the object is a plain object. * @method isPlainObject * @param {object} obj * @return {boolean} True if the
    object is a plain object, otherwise false */i.isPlainObject=function(e){return"object"===typeof e&&e.constructor===Object}; /** * Returns true if the object is a string. * @method isString * @param {object} obj * @return {boolean} True if the object
    is a string, otherwise false */i.isString=function(e){return"[object String]"===toString.call(e)}; /** * Returns the given value clamped between a minimum and maximum value. * @method clamp * @param {number} value * @param {number} min * @param {number}
    max * @return {number} The value clamped between min and max inclusive */i.clamp=function(e,t,n){return e
    <t?t:e>n?n:e}; /** * Returns the sign of the given value. * @method sign * @param {number} value * @return {number} -1 if negative, +1 if 0 or positive */i.sign=function(e){return e
        <0?-1:1};i.now=function(){if( "undefined"!==typeof window&&window.performance){if(window.performance.now)return
            window.performance.now();if(window.performance.webkitNow)return window.performance.webkitNow()}return Date.now?Date.now():new Date-i._nowStartTime}; /** * Returns a random value between a minimum and a maximum value inclusive. * The function uses
            a seeded random generator. * @method random * @param {number} min * @param {number} max * @return {number} A random number between min and max inclusive */i.random=function(e,t){e="undefined" !==typeof e?e:0;t="undefined" !==typeof t?t:1;return
            e+_seededRandom()*(t-e)};var _seededRandom=function(){i._seed=(9301*i._seed+49297)%233280;return i._seed/233280}; /** * Converts a CSS hex colour string into an integer. * @method colorToNumber * @param {string} colorString * @return {number}
            An integer representing the CSS hex string */i.colorToNumber=function(e){e=e.replace( "#", "");3==e.length&&(e=e.charAt(0)+e.charAt(0)+e.charAt(1)+e.charAt(1)+e.charAt(2)+e.charAt(2));return parseInt(e,16)}; /** * The console logging level to
            use, where each level includes all levels above and excludes the levels below. * The default level is 'debug' which shows all console messages. * * Possible level values are: * - 0=N one * - 1=D ebug * - 2=I nfo * - 3=W arn * - 4=E rror * @property
            Common.logLevel * @type {Number} * @default 1 */i.logLevel=1; /** * Shows a `console.log` message only if the current `Common.logLevel` allows it. * The message will be prefixed with 'matter-js' to make it easily identifiable. * @method log *
            @param ...objs {} The objects to log. */i.log=function(){console&&i.logLevel>0&&i.logLevel
            <=3&&console.log.apply(console,[ "matter-js:"].concat(Array.prototype.slice.call(arguments)))}; /** * Shows a `console.info` message only if the current `Common.logLevel` allows it. * The message will be prefixed with 'matter-js'
                to make it easily identifiable. * @method info * @param ...objs {} The objects to log. */i.info=function(){console&&i.logLevel>0&&i.logLevel
                <=2&&console.info.apply(console,[ "matter-js:"].concat(Array.prototype.slice.call(arguments)))}; /** * Shows a `console.warn` message only if the current `Common.logLevel` allows it. * The message will be prefixed with
                    'matter-js' to make it easily identifiable. * @method warn * @param ...objs {} The objects to log. */i.warn=function(){console&&i.logLevel>0&&i.logLevel
                    <=3&&console.warn.apply(console,[ "matter-js:"].concat(Array.prototype.slice.call(arguments)))}; /** * Uses `Common.warn` to log the given message one time only. * @method warnOnce * @param ...objs {} The objects to log. */i.warnOnce=function(){var
                        e=Array.prototype.slice.call(arguments).join( " ");if(!i._warnedOnce[e]){i.warn(e);i._warnedOnce[e]=true}}; /** * Shows a deprecated console warning when the function on the given object is called. * The target function will be replaced
                        with a new function that first shows the warning * and then calls the original function. * @method deprecated * @param {object} obj The object or module * @param {string} name The property name of the function on obj * @param {string}
                        warning The one-time message to show if the function is called */i.deprecated=function(e,t,n){e[t]=i.chain((function(){i.warnOnce( "ðŸ”… deprecated ðŸ”…",n)}),e[t])};i.nextId=function(){return i._nextId++}; /** * A cross browser compatible
                        indexOf implementation. * @method indexOf * @param {array} haystack * @param {object} needle * @return {number} The position of needle in haystack, otherwise -1. */i.indexOf=function(e,t){if(e.indexOf)return e.indexOf(t);for(var n=0;n<e.length;n++)if(e[n]===t)return
                        n;return-1}; /** * A cross browser compatible array map implementation. * @method map * @param {array} list * @param {function} func * @return {array} Values from list transformed by func. */i.map=function(e,t){if(e.map)return e.map(t);var
                        n=[];for(var i=0;i<e.length;i+=1)n.push(t(e[i]));return n}; /** * Takes a directed graph and returns the partially ordered set of vertices in topological order. * Circular dependencies are allowed. * @method topologicalSort * @param
                        {object} graph * @return {array} Partially ordered set of vertices in topological order. */i.topologicalSort=function(e){var t=[],n=[],o=[];for(var r in e)n[r]||o[r]||i._topologicalSort(r,n,o,e,t);return t};i._topologicalSort=function(e,t,n,o,r){var
                        a=o[e]||[];n[e]=true;for(var s=0;s<a.length;s+=1){var l=a[s];n[l]||(t[l]||i._topologicalSort(l,t,n,o,r))}n[e]=false;t[e]=true;r.push(e)}; /** * Takes _n_ functions as arguments and returns a new function that calls them in order. *
                        The arguments applied when calling the new function will also be applied to every function passed. * The value of `this` refers to the last value returned in the chain that was not `undefined`. * Therefore if a passed function does
                        not return a value, the previously returned value is maintained. * After all passed functions have been called the new function returns the last returned value (if any). * If any of the passed functions are a chain, then the chain
                        will be flattened. * @method chain * @param ...funcs {function} The functions to chain. * @return {function} A new function that calls the passed functions in order. */i.chain=function(){var e=[];for(var t=0;t<arguments.length;t+=1){var
                        n=arguments[t];n._chained?e.push.apply(e,n._chained):e.push(n)}var chain=function(){var t,n=new Array(arguments.length);for(var i=0,o=arguments.length;i<o;i++)n[i]=arguments[i];for(i=0;i<e.length;i+=1){var r=e[i].apply(t,n);
                        "undefined"!==typeof r&&(t=r)}return t};chain._chained=e;return chain}; /** * Chains a function to excute before the original function on the given `path` relative to `base`. * See also docs for `Common.chain`. * @method chainPathBefore * @param
                        {} base The base object * @param {string} path The path relative to `base` * @param {function} func The function to chain before the original * @return {function} The chained function that replaced the original */i.chainPathBefore=function(e,t,n){return
                        i.set(e,t,i.chain(n,i.get(e,t)))}; /** * Chains a function to excute after the original function on the given `path` relative to `base`. * See also docs for `Common.chain`. * @method chainPathAfter * @param {} base The base object
                        * @param {string} path The path relative to `base` * @param {function} func The function to chain after the original * @return {function} The chained function that replaced the original */i.chainPathAfter=function(e,t,n){return i.set(e,t,i.chain(i.get(e,t),n))};
                    /** * Provide the [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module to enable * concave vertex decomposition support when using `Bodies.fromVertices` e.g. `Common.setDecomp(require( 'poly-decomp'))`. * @method
                        setDecomp * @param {} decomp The [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module. */i.setDecomp=function(e){i._decomp=e};i.getDecomp=function(){var t=i._decomp;try{t|| "undefined"===typeof window||(t=window.decomp);t||
                        "undefined"===typeof e||(t=e.decomp)}catch(e){t=null}return t}})()},function(e,t){var n={};e.exports=n;(function(){ /** * Creates a new axis-aligned bounding box (AABB) for the given vertices. * @method create * @param {vertices} vertices *
                        @return {bounds} A new bounds object */ n.create=function(e){var t={min:{x:0,y:0},max:{x:0,y:0}};e&&n.update(t,e);return t}; /** * Updates bounds using the given vertices and extends the bounds given a velocity. * @method update *
                        @param {bounds} bounds * @param {vertices} vertices * @param {vector} velocity */n.update=function(e,t,n){e.min.x=Infinity;e.max.x=-Infinity;e.min.y=Infinity;e.max.y=-Infinity;for(var i=0;i<t.length;i++){var o=t[i];o.x>e.max.x&&(e.max.x=o.x);o.x
                        <e.min.x&&(e.min.x=o.x);o.y>e.max.y&&(e.max.y=o.y);o.y
                            <e.min.y&&(e.min.y=o.y)}if(n){n.x>0?e.max.x+=n.x:e.min.x+=n.x;n.y>0?e.max.y+=n.y:e.min.y+=n.y}}; /** * Returns true if the bounds contains the given point. * @method contains * @param {bounds} bounds * @param {vector} point * @return {boolean} True if the bounds
                                contain the point, otherwise false */n.contains=function(e,t){return t.x>=e.min.x&&t.x
                                <=e.max.x&&t.y>=e.min.y&&t.y
                                    <=e.max.y}; /** * Returns true if the two bounds intersect. * @method overlaps * @param {bounds} boundsA * @param {bounds} boundsB * @return {boolean} True if the bounds overlap, otherwise false */n.overlaps=function(e,t){return
                                        e.min.x<=t.max.x&&e.max.x>=t.min.x&&e.max.y>=t.min.y&&e.min.y
                                        <=t.max.y}; /** * Translates the bounds by the given vector. * @method translate * @param {bounds} bounds * @param {vector} vector */n.translate=function(e,t){e.min.x+=t.x;e.max.x+=t.x;e.min.y+=t.y;e.max.y+=t.y};
                                        /** * Shifts the bounds to the given position. * @method shift * @param {bounds} bounds * @param {vector} position */n.shift=function(e,t){var n=e.max.x-e.min.x,i=e.max.y-e.min.y;e.min.x=t.x;e.max.x=t.x+n;e.min.y=t.y;e.max.y=t.y+i}})()},function(e,t){var
                                            n={};e.exports=n;(function(){ /** * Creates a new vector. * @method create * @param {number} x * @param {number} y * @return {vector} A new vector */ n.create=function(e,t){return{x:e||0,y:t||0}}; /** * Returns
                                            a new vector with `x` and `y` copied from the given `vector`. * @method clone * @param {vector} vector * @return {vector} A new cloned vector */n.clone=function(e){return{x:e.x,y:e.y}}; /** * Returns the magnitude
                                            (length) of a vector. * @method magnitude * @param {vector} vector * @return {number} The magnitude of the vector */n.magnitude=function(e){return Math.sqrt(e.x*e.x+e.y*e.y)}; /** * Returns the magnitude (length)
                                            of a vector (therefore saving a `sqrt` operation). * @method magnitudeSquared * @param {vector} vector * @return {number} The squared magnitude of the vector */n.magnitudeSquared=function(e){return e.x*e.x+e.y*e.y};
                                        /** * Rotates the vector about (0, 0) by specified angle. * @method rotate * @param {vector} vector * @param {number} angle * @param {vector} [output] * @return {vector} The vector rotated about (0, 0) */n.rotate=function(e,t,n){var
                                            i=Math.cos(t),o=Math.sin(t);n||(n={});var r=e.x*i-e.y*o;n.y=e.x*o+e.y*i;n.x=r;return n}; /** * Rotates the vector about a specified point by specified angle. * @method rotateAbout * @param {vector} vector * @param
                                            {number} angle * @param {vector} point * @param {vector} [output] * @return {vector} A new vector rotated about the point */n.rotateAbout=function(e,t,n,i){var o=Math.cos(t),r=Math.sin(t);i||(i={});var a=n.x+((e.x-n.x)*o-(e.y-n.y)*r);i.y=n.y+((e.x-n.x)*r+(e.y-n.y)*o);i.x=a;return
                                            i}; /** * Normalises a vector (such that its magnitude is `1`). * @method normalise * @param {vector} vector * @return {vector} A new vector normalised */n.normalise=function(e){var t=n.magnitude(e);return 0===t?{x:0,y:0}:{x:e.x/t,y:e.y/t}};
                                        /** * Returns the dot-product of two vectors. * @method dot * @param {vector} vectorA * @param {vector} vectorB * @return {number} The dot product of the two vectors */n.dot=function(e,t){return e.x*t.x+e.y*t.y};
                                        /** * Returns the cross-product of two vectors. * @method cross * @param {vector} vectorA * @param {vector} vectorB * @return {number} The cross product of the two vectors */n.cross=function(e,t){return e.x*t.y-e.y*t.x};
                                        /** * Returns the cross-product of three vectors. * @method cross3 * @param {vector} vectorA * @param {vector} vectorB * @param {vector} vectorC * @return {number} The cross product of the three vectors */n.cross3=function(e,t,n){return(t.x-e.x)*(n.y-e.y)-(t.y-e.y)*(n.x-e.x)};
                                        /** * Adds the two vectors. * @method add * @param {vector} vectorA * @param {vector} vectorB * @param {vector} [output] * @return {vector} A new vector of vectorA and vectorB added */n.add=function(e,t,n){n||(n={});n.x=e.x+t.x;n.y=e.y+t.y;return
                                            n}; /** * Subtracts the two vectors. * @method sub * @param {vector} vectorA * @param {vector} vectorB * @param {vector} [output] * @return {vector} A new vector of vectorA and vectorB subtracted */n.sub=function(e,t,n){n||(n={});n.x=e.x-t.x;n.y=e.y-t.y;return
                                            n}; /** * Multiplies a vector and a scalar. * @method mult * @param {vector} vector * @param {number} scalar * @return {vector} A new vector multiplied by scalar */n.mult=function(e,t){return{x:e.x*t,y:e.y*t}};
                                        /** * Divides a vector and a scalar. * @method div * @param {vector} vector * @param {number} scalar * @return {vector} A new vector divided by scalar */n.div=function(e,t){return{x:e.x/t,y:e.y/t}}; /** * Returns
                                            the perpendicular vector. Set `negate` to true for the perpendicular in the opposite direction. * @method perp * @param {vector} vector * @param {bool} [negate=false] * @return {vector} The perpendicular vector
                                            */n.perp=function(e,t){t=true===t?-1:1;return{x:t*-e.y,y:t*e.x}}; /** * Negates both components of a vector such that it points in the opposite direction. * @method neg * @param {vector} vector * @return {vector}
                                            The negated vector */n.neg=function(e){return{x:-e.x,y:-e.y}}; /** * Returns the angle between the vector `vectorB - vectorA` and the x-axis in radians. * @method angle * @param {vector} vectorA * @param {vector}
                                            vectorB * @return {number} The angle in radians */n.angle=function(e,t){return Math.atan2(t.y-e.y,t.x-e.x)}; /** * Temporary vector pool (not thread-safe). * @property _temp * @type {vector[]} * @private */n._temp=[n.create(),n.create(),n.create(),n.create(),n.create(),n.create()]})()},function(e,t,n){var
                                            i={};e.exports=i;var o=n(2);var r=n(0);(function(){ /** * Creates a new set of `Matter.Body` compatible vertices. * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0,
                                            0)`, for example: * * [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }] * * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects, * but with some additional
                                            references required for efficient collision detection routines. * * Vertices must be specified in clockwise order. * * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided. *
                                            * @method create * @param {vector[]} points * @param {body} body */ i.create=function(e,t){var n=[];for(var i=0;i<e.length;i++){var o=e[i],r={x:o.x,y:o.y,index:i,body:t,isInternal:false};n.push(r)}return n}; /**
                                            * Parses a string containing ordered x y pairs separated by spaces (and optionally commas), * into a `Matter.Vertices` object for the given `Matter.Body`. * For parsing SVG paths, see `Svg.pathToVertices`. * @method
                                            fromPath * @param {string} path * @param {body} body * @return {vertices} vertices */i.fromPath=function(e,t){var n=/L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/gi,o=[];e.replace(n,(function(e,t,n){o.push({x:parseFloat(t),y:parseFloat(n)})}));return
                                            i.create(o,t)}; /** * Returns the centre (centroid) of the set of vertices. * @method centre * @param {vertices} vertices * @return {vector} The centre point */i.centre=function(e){var t,n,r,a=i.area(e,true),s={x:0,y:0};for(var
                                            l=0;l<e.length;l++){r=(l+1)%e.length;t=o.cross(e[l],e[r]);n=o.mult(o.add(e[l],e[r]),t);s=o.add(s,n)}return o.div(s,6*a)}; /** * Returns the average (mean) of the set of vertices. * @method mean * @param {vertices}
                                            vertices * @return {vector} The average point */i.mean=function(e){var t={x:0,y:0};for(var n=0;n<e.length;n++){t.x+=e[n].x;t.y+=e[n].y}return o.div(t,e.length)}; /** * Returns the area of the set of vertices. *
                                            @method area * @param {vertices} vertices * @param {bool} signed * @return {number} The area */i.area=function(e,t){var n=0,i=e.length-1;for(var o=0;o<e.length;o++){n+=(e[i].x-e[o].x)*(e[i].y+e[o].y);i=o}return
                                            t?n/2:Math.abs(n)/2}; /** * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass. * @method inertia * @param {vertices} vertices * @param {number} mass * @return {number}
                                            The polygon 's moment of inertia
         */i.inertia=function(e,t){var n,i,r=0,a=0,s=e;for(var l=0;l<s.length;l++){i=(l+1)%s.length;n=Math.abs(o.cross(s[i],s[l]));r+=n*(o.dot(s[i],s[i])+o.dot(s[i],s[l])+o.dot(s[l],s[l]));a+=n}return t/6*(r/a)};
/**
         * Translates the set of vertices in-place.
         * @method translate
         * @param {vertices} vertices
         * @param {vector} vector
         * @param {number} scalar
         */i.translate=function(e,t,n){n="undefined"!==typeof n?n:1;var i,o=e.length,r=t.x*n,a=t.y*n;for(i=0;i<o;i++){e[i].x+=r;e[i].y+=a}return e};
/**
         * Rotates the set of vertices in-place.
         * @method rotate
         * @param {vertices} vertices
         * @param {number} angle
         * @param {vector} point
         */i.rotate=function(e,t,n){if(0!==t){var i,o,r,a,s=Math.cos(t),l=Math.sin(t),c=n.x,u=n.y,f=e.length;for(a=0;a<f;a++){i=e[a];o=i.x-c;r=i.y-u;i.x=c+(o*s-r*l);i.y=u+(o*l+r*s)}return e}};
/**
         * Returns `true` if the `point` is inside the set of `vertices`.
         * @method contains
         * @param {vertices} vertices
         * @param {vector} point
         * @return {boolean} True if the vertices contains point, otherwise false
         */i.contains=function(e,t){var n,i=t.x,o=t.y,r=e.length,a=e[r-1];for(var s=0;s<r;s++){n=e[s];if((i-a.x)*(n.y-a.y)+(o-a.y)*(a.x-n.x)>0)return false;a=n}return true};
/**
         * Scales the vertices from a point (default is centre) in-place.
         * @method scale
         * @param {vertices} vertices
         * @param {number} scaleX
         * @param {number} scaleY
         * @param {vector} point
         */i.scale=function(e,t,n,r){if(1===t&&1===n)return e;r=r||i.centre(e);var a,s;for(var l=0;l<e.length;l++){a=e[l];s=o.sub(a,r);e[l].x=r.x+s.x*t;e[l].y=r.y+s.y*n}return e};
/**
         * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.
         * The radius parameter is a single number or an array to specify the radius for each vertex.
         * @method chamfer
         * @param {vertices} vertices
         * @param {number[]} radius
         * @param {number} quality
         * @param {number} qualityMin
         * @param {number} qualityMax
         */i.chamfer=function(e,t,n,i,a){t="number"===typeof t?[t]:t||[8];n="undefined"!==typeof n?n:-1;i=i||2;a=a||14;var s=[];for(var l=0;l<e.length;l++){var c=e[l-1>=0?l-1:e.length-1],u=e[l],f=e[(l+1)%e.length],d=t[l<t.length?l:t.length-1];if(0!==d){var p=o.normalise({x:u.y-c.y,y:c.x-u.x});var v=o.normalise({x:f.y-u.y,y:u.x-f.x});var y=Math.sqrt(2*Math.pow(d,2)),m=o.mult(r.clone(p),d),g=o.normalise(o.mult(o.add(p,v),.5)),x=o.sub(u,o.mult(g,y));var h=n;-1===n&&(h=1.75*Math.pow(d,.32));h=r.clamp(h,i,a);h%2===1&&(h+=1);var b=Math.acos(o.dot(p,v)),S=b/h;for(var w=0;w<h;w++)s.push(o.add(o.rotate(m,S*w),x))}else s.push(u)}return s};
/**
         * Sorts the input vertices into clockwise order in place.
         * @method clockwiseSort
         * @param {vertices} vertices
         * @return {vertices} vertices
         */i.clockwiseSort=function(e){var t=i.mean(e);e.sort((function(e,n){return o.angle(t,e)-o.angle(t,n)}));return e};
/**
         * Returns true if the vertices form a convex shape (vertices must be in clockwise order).
         * @method isConvex
         * @param {vertices} vertices
         * @return {bool} `true` if the `vertices` are convex, `false` if not (or `null` if not computable).
         */i.isConvex=function(e){var t,n,i,o,r=0,a=e.length;if(a<3)return null;for(t=0;t<a;t++){n=(t+1)%a;i=(t+2)%a;o=(e[n].x-e[t].x)*(e[i].y-e[n].y);o-=(e[n].y-e[t].y)*(e[i].x-e[n].x);o<0?r|=1:o>0&&(r|=2);if(3===r)return false}return 0!==r||null};
/**
         * Returns the convex hull of the input vertices as a new array of points.
         * @method hull
         * @param {vertices} vertices
         * @return [vertex] vertices
         */i.hull=function(e){var t,n,i=[],r=[];e=e.slice(0);e.sort((function(e,t){var n=e.x-t.x;return 0!==n?n:e.y-t.y}));for(n=0;n<e.length;n+=1){t=e[n];while(r.length>=2&&o.cross3(r[r.length-2],r[r.length-1],t)<=0)r.pop();r.push(t)}for(n=e.length-1;n>=0;n-=1){t=e[n];while(i.length>=2&&o.cross3(i[i.length-2],i[i.length-1],t)<=0)i.pop();i.push(t)}i.pop();r.pop();return i.concat(r)}})()},function(e,t,n){var i={};e.exports=i;var o=n(0);(function(){
/**
         * Subscribes a callback function to the given object's `eventName`. * @method on * @param {} object * @param {string} eventNames * @param {function} callback */ i.on=function(e,t,n){var i,o=t.split( " ");for(var r=0;r<o.length;r++){i=o[r];e.events=e.events||{};e.events[i]=e.events[i]||[];e.events[i].push(n)}return
                                            n}; /** * Removes the given event callback. If no callback, clears all callbacks in `eventNames`. If no `eventNames`, clears all events. * @method off * @param {} object * @param {string} eventNames * @param {function}
                                            callback */i.off=function(e,t,n){if(t){if( "function"===typeof t){n=t;t=o.keys(e.events).join( " ")}var i=t.split( " ");for(var r=0;r<i.length;r++){var a=e.events[i[r]],s=[];if(n&&a)for(var l=0;l<a.length;l++)a[l]!==n&&s.push(a[l]);e.events[i[r]]=s}}else
                                            e.events={}}; /** * Fires all the callbacks subscribed to the given object 's `eventName`, in the order they subscribed, if any.
         * @method trigger
         * @param {} object
         * @param {string} eventNames
         * @param {} event
         */i.trigger=function(e,t,n){var i,r,a,s;var l=e.events;if(l&&o.keys(l).length>0){n||(n={});i=t.split(" ");for(var c=0;c<i.length;c++){r=i[c];a=l[r];if(a){s=o.clone(n,false);s.name=r;s.source=e;for(var u=0;u<a.length;u++)a[u].apply(e,[s])}}}}})()},function(e,t,n){var i={};e.exports=i;var o=n(4);var r=n(0);var a=n(1);var s=n(6);(function(){
/**
         * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.
         * See the properites section below for detailed information on what you can pass via the `options` object.
         * @method create
         * @param {} [options]
         * @return {composite} A new composite
         */
i.create=function(e){return r.extend({id:r.nextId(),type:"composite",parent:null,isModified:false,bodies:[],constraints:[],composites:[],label:"Composite",plugin:{},cache:{allBodies:null,allConstraints:null,allComposites:null}},e)};
/**
         * Sets the composite's `isModified` flag. * If `updateParents` is true, all parents will be set (default: false). * If `updateChildren` is true, all children will be set (default: false). * @private * @method setModified * @param {composite}
                                            composite * @param {boolean} isModified * @param {boolean} [updateParents=false] * @param {boolean} [updateChildren=false] */i.setModified=function(e,t,n,o){e.isModified=t;if(t&&e.cache){e.cache.allBodies=null;e.cache.allConstraints=null;e.cache.allComposites=null}n&&e.parent&&i.setModified(e.parent,t,n,o);if(o)for(var
                                            r=0;r<e.composites.length;r++){var a=e.composites[r];i.setModified(a,t,n,o)}}; /** * Generic single or multi-add function. Adds a single or an array of body(s), constraint(s) or composite(s) to the given composite.
                                            * Triggers `beforeAdd` and `afterAdd` events on the `composite`. * @method add * @param {composite} composite * @param {object|array} object A single or an array of body(s), constraint(s) or composite(s) * @return
                                            {composite} The original composite with the objects added */i.add=function(e,t){var n=[].concat(t);o.trigger(e, "beforeAdd",{object:t});for(var a=0;a<n.length;a++){var s=n[a];switch(s.type){case "body":if(s.parent!==s){r.warn(
                                            "Composite.add: skipped adding a compound body part (you must add its parent instead)");break}i.addBody(e,s);break;case "constraint":i.addConstraint(e,s);break;case "composite":i.addComposite(e,s);break;case "mouseConstraint":i.addConstraint(e,s.constraint);break}}o.trigger(e, "afterAdd",{object:t});return
                                            e}; /** * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite. * Optionally searching its children recursively. * Triggers `beforeRemove` and `afterRemove`
                                            events on the `composite`. * @method remove * @param {composite} composite * @param {object|array} object * @param {boolean} [deep=false] * @return {composite} The original composite with the objects removed */i.remove=function(e,t,n){var
                                            r=[].concat(t);o.trigger(e, "beforeRemove",{object:t});for(var a=0;a<r.length;a++){var s=r[a];switch(s.type){case "body":i.removeBody(e,s,n);break;case "constraint":i.removeConstraint(e,s,n);break;case
                                            "composite":i.removeComposite(e,s,n);break;case "mouseConstraint":i.removeConstraint(e,s.constraint);break}}o.trigger(e, "afterRemove",{object:t});return e}; /** * Adds a composite to the given composite. * @private * @method
                                            addComposite * @param {composite} compositeA * @param {composite} compositeB * @return {composite} The original compositeA with the objects from compositeB added */i.addComposite=function(e,t){e.composites.push(t);t.parent=e;i.setModified(e,true,true,false);return
                                            e}; /** * Removes a composite from the given composite, and optionally searching its children recursively. * @private * @method removeComposite * @param {composite} compositeA * @param {composite} compositeB * @param
                                            {boolean} [deep=false] * @return {composite} The original compositeA with the composite removed */i.removeComposite=function(e,t,n){var o=r.indexOf(e.composites,t);-1!==o&&i.removeCompositeAt(e,o);if(n)for(var a=0;a<e.composites.length;a++)i.removeComposite(e.composites[a],t,true);return
                                            e}; /** * Removes a composite from the given composite. * @private * @method removeCompositeAt * @param {composite} composite * @param {number} position * @return {composite} The original composite with the composite
                                            removed */i.removeCompositeAt=function(e,t){e.composites.splice(t,1);i.setModified(e,true,true,false);return e}; /** * Adds a body to the given composite. * @private * @method addBody * @param {composite} composite
                                            * @param {body} body * @return {composite} The original composite with the body added */i.addBody=function(e,t){e.bodies.push(t);i.setModified(e,true,true,false);return e}; /** * Removes a body from the given composite,
                                            and optionally searching its children recursively. * @private * @method removeBody * @param {composite} composite * @param {body} body * @param {boolean} [deep=false] * @return {composite} The original composite
                                            with the body removed */i.removeBody=function(e,t,n){var o=r.indexOf(e.bodies,t);-1!==o&&i.removeBodyAt(e,o);if(n)for(var a=0;a<e.composites.length;a++)i.removeBody(e.composites[a],t,true);return e}; /** * Removes
                                            a body from the given composite. * @private * @method removeBodyAt * @param {composite} composite * @param {number} position * @return {composite} The original composite with the body removed */i.removeBodyAt=function(e,t){e.bodies.splice(t,1);i.setModified(e,true,true,false);return
                                            e}; /** * Adds a constraint to the given composite. * @private * @method addConstraint * @param {composite} composite * @param {constraint} constraint * @return {composite} The original composite with the constraint
                                            added */i.addConstraint=function(e,t){e.constraints.push(t);i.setModified(e,true,true,false);return e}; /** * Removes a constraint from the given composite, and optionally searching its children recursively. * @private
                                            * @method removeConstraint * @param {composite} composite * @param {constraint} constraint * @param {boolean} [deep=false] * @return {composite} The original composite with the constraint removed */i.removeConstraint=function(e,t,n){var
                                            o=r.indexOf(e.constraints,t);-1!==o&&i.removeConstraintAt(e,o);if(n)for(var a=0;a<e.composites.length;a++)i.removeConstraint(e.composites[a],t,true);return e}; /** * Removes a body from the given composite. * @private
                                            * @method removeConstraintAt * @param {composite} composite * @param {number} position * @return {composite} The original composite with the constraint removed */i.removeConstraintAt=function(e,t){e.constraints.splice(t,1);i.setModified(e,true,true,false);return
                                            e}; /** * Removes all bodies, constraints and composites from the given composite. * Optionally clearing its children recursively. * @method clear * @param {composite} composite * @param {boolean} keepStatic * @param
                                            {boolean} [deep=false] */i.clear=function(e,t,n){if(n)for(var o=0;o<e.composites.length;o++)i.clear(e.composites[o],t,true);t?e.bodies=e.bodies.filter((function(e){return e.isStatic})):e.bodies.length=0;e.constraints.length=0;e.composites.length=0;i.setModified(e,true,true,false);return
                                            e}; /** * Returns all bodies in the given composite, including all bodies in its children, recursively. * @method allBodies * @param {composite} composite * @return {body[]} All the bodies */i.allBodies=function(e){if(e.cache&&e.cache.allBodies)return
                                            e.cache.allBodies;var t=[].concat(e.bodies);for(var n=0;n<e.composites.length;n++)t=t.concat(i.allBodies(e.composites[n]));e.cache&&(e.cache.allBodies=t);return t}; /** * Returns all constraints in the given composite,
                                            including all constraints in its children, recursively. * @method allConstraints * @param {composite} composite * @return {constraint[]} All the constraints */i.allConstraints=function(e){if(e.cache&&e.cache.allConstraints)return
                                            e.cache.allConstraints;var t=[].concat(e.constraints);for(var n=0;n<e.composites.length;n++)t=t.concat(i.allConstraints(e.composites[n]));e.cache&&(e.cache.allConstraints=t);return t}; /** * Returns all composites
                                            in the given composite, including all composites in its children, recursively. * @method allComposites * @param {composite} composite * @return {composite[]} All the composites */i.allComposites=function(e){if(e.cache&&e.cache.allComposites)return
                                            e.cache.allComposites;var t=[].concat(e.composites);for(var n=0;n<e.composites.length;n++)t=t.concat(i.allComposites(e.composites[n]));e.cache&&(e.cache.allComposites=t);return t}; /** * Searches the composite recursively
                                            for an object matching the type and id supplied, null if not found. * @method get * @param {composite} composite * @param {number} id * @param {string} type * @return {object} The requested object, if found */i.get=function(e,t,n){var
                                            o,r;switch(n){case "body":o=i.allBodies(e);break;case "constraint":o=i.allConstraints(e);break;case "composite":o=i.allComposites(e).concat(e);break}if(!o)return null;r=o.filter((function(e){return e.id.toString()===t.toString()}));return
                                            0===r.length?null:r[0]}; /** * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add). * @method move * @param {compositeA} compositeA * @param {object[]} objects * @param
                                            {compositeB} compositeB * @return {composite} Returns compositeA */i.move=function(e,t,n){i.remove(e,t);i.add(n,t);return e}; /** * Assigns new ids for all objects in the composite, recursively. * @method rebase
                                            * @param {composite} composite * @return {composite} Returns composite */i.rebase=function(e){var t=i.allBodies(e).concat(i.allConstraints(e)).concat(i.allComposites(e));for(var n=0;n<t.length;n++)t[n].id=r.nextId();return
                                            e}; /** * Translates all children in the composite by a given vector relative to their current positions, * without imparting any velocity. * @method translate * @param {composite} composite * @param {vector} translation
                                            * @param {bool} [recursive=true] */i.translate=function(e,t,n){var o=n?i.allBodies(e):e.bodies;for(var r=0;r<o.length;r++)s.translate(o[r],t);return e}; /** * Rotates all children in the composite by a given angle
                                            about the given point, without imparting any angular velocity. * @method rotate * @param {composite} composite * @param {number} rotation * @param {vector} point * @param {bool} [recursive=true] */i.rotate=function(e,t,n,o){var
                                            r=Math.cos(t),a=Math.sin(t),l=o?i.allBodies(e):e.bodies;for(var c=0;c<l.length;c++){var u=l[c],f=u.position.x-n.x,d=u.position.y-n.y;s.setPosition(u,{x:n.x+(f*r-d*a),y:n.y+(f*a+d*r)});s.rotate(u,t)}return e}; /**
                                            * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point. * @method scale * @param {composite} composite * @param {number} scaleX * @param
                                            {number} scaleY * @param {vector} point * @param {bool} [recursive=true] */i.scale=function(e,t,n,o,r){var a=r?i.allBodies(e):e.bodies;for(var l=0;l<a.length;l++){var c=a[l],u=c.position.x-o.x,f=c.position.y-o.y;s.setPosition(c,{x:o.x+u*t,y:o.y+f*n});s.scale(c,t,n)}return
                                            e}; /** * Returns the union of the bounds of all of the composite 's bodies.
         * @method bounds
         * @param {composite} composite The composite.
         * @returns {bounds} The composite bounds.
         */i.bounds=function(e){var t=i.allBodies(e),n=[];for(var o=0;o<t.length;o+=1){var r=t[o];n.push(r.bounds.min,r.bounds.max)}return a.create(n)};
/**
        * Fired when a call to `Composite.add` is made, before objects have been added.
        *
        * @event beforeAdd
        * @param {} event An event object
        * @param {} event.object The object(s) to be added (may be a single body, constraint, composite or a mixed array of these)
        * @param {} event.source The source object of the event
        * @param {} event.name The name of the event
        */
/**
        * Fired when a call to `Composite.add` is made, after objects have been added.
        *
        * @event afterAdd
        * @param {} event An event object
        * @param {} event.object The object(s) that have been added (may be a single body, constraint, composite or a mixed array of these)
        * @param {} event.source The source object of the event
        * @param {} event.name The name of the event
        */
/**
        * Fired when a call to `Composite.remove` is made, before objects have been removed.
        *
        * @event beforeRemove
        * @param {} event An event object
        * @param {} event.object The object(s) to be removed (may be a single body, constraint, composite or a mixed array of these)
        * @param {} event.source The source object of the event
        * @param {} event.name The name of the event
        */
/**
        * Fired when a call to `Composite.remove` is made, after objects have been removed.
        *
        * @event afterRemove
        * @param {} event An event object
        * @param {} event.object The object(s) that have been removed (may be a single body, constraint, composite or a mixed array of these)
        * @param {} event.source The source object of the event
        * @param {} event.name The name of the event
        */
/**
         * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.
         *
         * @property id
         * @type number
         */
/**
         * A `String` denoting the type of object.
         *
         * @property type
         * @type string
         * @default "composite"
         * @readOnly
         */
/**
         * An arbitrary `String` name to help the user identify and manage composites.
         *
         * @property label
         * @type string
         * @default "Composite"
         */
/**
         * A flag that specifies whether the composite has been modified during the current step.
         * This is automatically managed when bodies, constraints or composites are added or removed.
         *
         * @property isModified
         * @type boolean
         * @default false
         */
/**
         * The `Composite` that is the parent of this composite. It is automatically managed by the `Matter.Composite` methods.
         *
         * @property parent
         * @type composite
         * @default null
         */
/**
         * An array of `Body` that are _direct_ children of this composite.
         * To add or remove bodies you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
         * If you wish to recursively find all descendants, you should use the `Composite.allBodies` method.
         *
         * @property bodies
         * @type body[]
         * @default []
         */
/**
         * An array of `Constraint` that are _direct_ children of this composite.
         * To add or remove constraints you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
         * If you wish to recursively find all descendants, you should use the `Composite.allConstraints` method.
         *
         * @property constraints
         * @type constraint[]
         * @default []
         */
/**
         * An array of `Composite` that are _direct_ children of this composite.
         * To add or remove composites you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
         * If you wish to recursively find all descendants, you should use the `Composite.allComposites` method.
         *
         * @property composites
         * @type composite[]
         * @default []
         */
/**
         * An object reserved for storing plugin-specific properties.
         *
         * @property plugin
         * @type {}
         */
/**
         * An object used for storing cached results for performance reasons.
         * This is used internally only and is automatically managed.
         *
         * @private
         * @property cache
         * @type {}
         */})()},function(e,t,n){var i={};e.exports=i;var o=n(3);var r=n(2);var a=n(7);n(16);var s=n(0);var l=n(1);var c=n(11);(function(){i._inertiaScale=4;i._nextCollidingGroupId=1;i._nextNonCollidingGroupId=-1;i._nextCategory=1;
/**
         * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.
         * All properties have default values, and many are pre-calculated automatically based on other properties.
         * Vertices must be specified in clockwise order.
         * See the properties section below for detailed information on what you can pass via the `options` object.
         * @method create
         * @param {} options
         * @return {body} body
         */i.create=function(e){var t={id:s.nextId(),type:"body",label:"Body",parts:[],plugin:{},angle:0,vertices:o.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"),position:{x:0,y:0},force:{x:0,y:0},torque:0,positionImpulse:{x:0,y:0},constraintImpulse:{x:0,y:0,angle:0},totalContacts:0,speed:0,angularSpeed:0,velocity:{x:0,y:0},angularVelocity:0,isSensor:false,isStatic:false,isSleeping:false,motion:0,sleepThreshold:60,density:.001,restitution:0,friction:.1,frictionStatic:.5,frictionAir:.01,collisionFilter:{category:1,mask:4294967295,group:0},slop:.05,timeScale:1,render:{visible:true,opacity:1,strokeStyle:null,fillStyle:null,lineWidth:null,sprite:{xScale:1,yScale:1,xOffset:0,yOffset:0}},events:null,bounds:null,chamfer:null,circleRadius:0,positionPrev:null,anglePrev:0,parent:null,axes:null,area:0,mass:0,inertia:0,_original:null};var n=s.extend(t,e);_initProperties(n,e);return n};
/**
         * Returns the next unique group index for which bodies will collide.
         * If `isNonColliding` is `true`, returns the next unique group index for which bodies will _not_ collide.
         * See `body.collisionFilter` for more information.
         * @method nextGroup
         * @param {bool} [isNonColliding=false]
         * @return {Number} Unique group index
         */i.nextGroup=function(e){return e?i._nextNonCollidingGroupId--:i._nextCollidingGroupId++};i.nextCategory=function(){i._nextCategory=i._nextCategory<<1;return i._nextCategory};
/**
         * Initialises body properties.
         * @method _initProperties
         * @private
         * @param {body} body
         * @param {} [options]
         */var _initProperties=function(e,t){t=t||{};i.set(e,{bounds:e.bounds||l.create(e.vertices),positionPrev:e.positionPrev||r.clone(e.position),anglePrev:e.anglePrev||e.angle,vertices:e.vertices,parts:e.parts||[e],isStatic:e.isStatic,isSleeping:e.isSleeping,parent:e.parent||e});o.rotate(e.vertices,e.angle,e.position);c.rotate(e.axes,e.angle);l.update(e.bounds,e.vertices,e.velocity);i.set(e,{axes:t.axes||e.axes,area:t.area||e.area,mass:t.mass||e.mass,inertia:t.inertia||e.inertia});var n=e.isStatic?"#14151f":s.choose(["#f19648","#f5d259","#f55a3c","#063e7b","#ececd1"]),a=e.isStatic?"#555":"#ccc",u=e.isStatic&&null===e.render.fillStyle?1:0;e.render.fillStyle=e.render.fillStyle||n;e.render.strokeStyle=e.render.strokeStyle||a;e.render.lineWidth=e.render.lineWidth||u;e.render.sprite.xOffset+=-(e.bounds.min.x-e.position.x)/(e.bounds.max.x-e.bounds.min.x);e.render.sprite.yOffset+=-(e.bounds.min.y-e.position.y)/(e.bounds.max.y-e.bounds.min.y)};
/**
         * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.
         * Prefer to use the actual setter functions in performance critical situations.
         * @method set
         * @param {body} body
         * @param {} settings A property name (or map of properties and values) to set on the body.
         * @param {} value The value to set if `settings` is a single property name.
         */i.set=function(e,t,n){var o;if("string"===typeof t){o=t;t={};t[o]=n}for(o in t)if(Object.prototype.hasOwnProperty.call(t,o)){n=t[o];switch(o){case"isStatic":i.setStatic(e,n);break;case"isSleeping":a.set(e,n);break;case"mass":i.setMass(e,n);break;case"density":i.setDensity(e,n);break;case"inertia":i.setInertia(e,n);break;case"vertices":i.setVertices(e,n);break;case"position":i.setPosition(e,n);break;case"angle":i.setAngle(e,n);break;case"velocity":i.setVelocity(e,n);break;case"angularVelocity":i.setAngularVelocity(e,n);break;case"parts":i.setParts(e,n);break;case"centre":i.setCentre(e,n);break;default:e[o]=n}}};
/**
         * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.
         * @method setStatic
         * @param {body} body
         * @param {bool} isStatic
         */i.setStatic=function(e,t){for(var n=0;n<e.parts.length;n++){var i=e.parts[n];i.isStatic=t;if(t){i._original={restitution:i.restitution,friction:i.friction,mass:i.mass,inertia:i.inertia,density:i.density,inverseMass:i.inverseMass,inverseInertia:i.inverseInertia};i.restitution=0;i.friction=1;i.mass=i.inertia=i.density=Infinity;i.inverseMass=i.inverseInertia=0;i.positionPrev.x=i.position.x;i.positionPrev.y=i.position.y;i.anglePrev=i.angle;i.angularVelocity=0;i.speed=0;i.angularSpeed=0;i.motion=0}else if(i._original){i.restitution=i._original.restitution;i.friction=i._original.friction;i.mass=i._original.mass;i.inertia=i._original.inertia;i.density=i._original.density;i.inverseMass=i._original.inverseMass;i.inverseInertia=i._original.inverseInertia;i._original=null}}};
/**
         * Sets the mass of the body. Inverse mass, density and inertia are automatically updated to reflect the change.
         * @method setMass
         * @param {body} body
         * @param {number} mass
         */i.setMass=function(e,t){var n=e.inertia/(e.mass/6);e.inertia=n*(t/6);e.inverseInertia=1/e.inertia;e.mass=t;e.inverseMass=1/e.mass;e.density=e.mass/e.area};
/**
         * Sets the density of the body. Mass and inertia are automatically updated to reflect the change.
         * @method setDensity
         * @param {body} body
         * @param {number} density
         */i.setDensity=function(e,t){i.setMass(e,t*e.area);e.density=t};
/**
         * Sets the moment of inertia (i.e. second moment of area) of the body. 
         * Inverse inertia is automatically updated to reflect the change. Mass is not changed.
         * @method setInertia
         * @param {body} body
         * @param {number} inertia
         */i.setInertia=function(e,t){e.inertia=t;e.inverseInertia=1/e.inertia};
/**
         * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`). * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.
                                            * They are then automatically translated to world space based on `body.position`. * * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array). * Vertices must
                                            form a convex hull, concave hulls are not supported. * * @method setVertices * @param {body} body * @param {vector[]} vertices */i.setVertices=function(e,t){t[0].body===e?e.vertices=t:e.vertices=o.create(t,e);e.axes=c.fromVertices(e.vertices);e.area=o.area(e.vertices);i.setMass(e,e.density*e.area);var
                                            n=o.centre(e.vertices);o.translate(e.vertices,n,-1);i.setInertia(e,i._inertiaScale*o.inertia(e.vertices,e.mass));o.translate(e.vertices,e.position);l.update(e.bounds,e.vertices,e.velocity)}; /** * Sets the parts
                                            of the `body` and updates mass, inertia and centroid. * Each part will have its parent set to `body`. * By default the convex hull will be automatically computed and set on `body`, unless `autoHull` is set to `false.`
                                            * Note that this method will ensure that the first part in `body.parts` will always be the `body`. * @method setParts * @param {body} body * @param [body] parts * @param {bool} [autoHull=true] */i.setParts=function(e,t,n){var
                                            r;t=t.slice(0);e.parts.length=0;e.parts.push(e);e.parent=e;for(r=0;r<t.length;r++){var a=t[r];if(a!==e){a.parent=e;e.parts.push(a)}}if(1!==e.parts.length){n="undefined"===typeof n||n;if(n){var s=[];for(r=0;r<t.length;r++)s=s.concat(t[r].vertices);o.clockwiseSort(s);var
                                            l=o.hull(s),c=o.centre(l);i.setVertices(e,l);o.translate(e.vertices,c)}var u=i._totalProperties(e);e.area=u.area;e.parent=e;e.position.x=u.centre.x;e.position.y=u.centre.y;e.positionPrev.x=u.centre.x;e.positionPrev.y=u.centre.y;i.setMass(e,u.mass);i.setInertia(e,u.inertia);i.setPosition(e,u.centre)}};
                                        /** * Set the centre of mass of the body. * The `centre` is a vector in world-space unless `relative` is set, in which case it is a translation. * The centre of mass is the point the body rotates about and can be
                                            used to simulate non-uniform density. * This is equal to moving `body.position` but not the `body.vertices`. * Invalid if the `centre` falls outside the body 's convex hull.
         * @method setCentre
         * @param {body} body
         * @param {vector} centre
         * @param {bool} relative
         */i.setCentre=function(e,t,n){if(n){e.positionPrev.x+=t.x;e.positionPrev.y+=t.y;e.position.x+=t.x;e.position.y+=t.y}else{e.positionPrev.x=t.x-(e.position.x-e.positionPrev.x);e.positionPrev.y=t.y-(e.position.y-e.positionPrev.y);e.position.x=t.x;e.position.y=t.y}};
/**
         * Sets the position of the body instantly. Velocity, angle, force etc. are unchanged.
         * @method setPosition
         * @param {body} body
         * @param {vector} position
         */i.setPosition=function(e,t){var n=r.sub(t,e.position);e.positionPrev.x+=n.x;e.positionPrev.y+=n.y;for(var i=0;i<e.parts.length;i++){var a=e.parts[i];a.position.x+=n.x;a.position.y+=n.y;o.translate(a.vertices,n);l.update(a.bounds,a.vertices,e.velocity)}};
/**
         * Sets the angle of the body instantly. Angular velocity, position, force etc. are unchanged.
         * @method setAngle
         * @param {body} body
         * @param {number} angle
         */i.setAngle=function(e,t){var n=t-e.angle;e.anglePrev+=n;for(var i=0;i<e.parts.length;i++){var a=e.parts[i];a.angle+=n;o.rotate(a.vertices,n,e.position);c.rotate(a.axes,n);l.update(a.bounds,a.vertices,e.velocity);i>0&&r.rotateAbout(a.position,n,e.position,a.position)}};
/**
         * Sets the linear velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
         * @method setVelocity
         * @param {body} body
         * @param {vector} velocity
         */i.setVelocity=function(e,t){e.positionPrev.x=e.position.x-t.x;e.positionPrev.y=e.position.y-t.y;e.velocity.x=t.x;e.velocity.y=t.y;e.speed=r.magnitude(e.velocity)};
/**
         * Sets the angular velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
         * @method setAngularVelocity
         * @param {body} body
         * @param {number} velocity
         */i.setAngularVelocity=function(e,t){e.anglePrev=e.angle-t;e.angularVelocity=t;e.angularSpeed=Math.abs(e.angularVelocity)};
/**
         * Moves a body by a given vector relative to its current position, without imparting any velocity.
         * @method translate
         * @param {body} body
         * @param {vector} translation
         */i.translate=function(e,t){i.setPosition(e,r.add(e.position,t))};
/**
         * Rotates a body by a given angle relative to its current angle, without imparting any angular velocity.
         * @method rotate
         * @param {body} body
         * @param {number} rotation
         * @param {vector} [point]
         */i.rotate=function(e,t,n){if(n){var o=Math.cos(t),r=Math.sin(t),a=e.position.x-n.x,s=e.position.y-n.y;i.setPosition(e,{x:n.x+(a*o-s*r),y:n.y+(a*r+s*o)});i.setAngle(e,e.angle+t)}else i.setAngle(e,e.angle+t)};
/**
         * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).
         * @method scale
         * @param {body} body
         * @param {number} scaleX
         * @param {number} scaleY
         * @param {vector} [point]
         */i.scale=function(e,t,n,r){var a=0,s=0;r=r||e.position;for(var u=0;u<e.parts.length;u++){var f=e.parts[u];o.scale(f.vertices,t,n,r);f.axes=c.fromVertices(f.vertices);f.area=o.area(f.vertices);i.setMass(f,e.density*f.area);o.translate(f.vertices,{x:-f.position.x,y:-f.position.y});i.setInertia(f,i._inertiaScale*o.inertia(f.vertices,f.mass));o.translate(f.vertices,{x:f.position.x,y:f.position.y});if(u>0){a+=f.area;s+=f.inertia}f.position.x=r.x+(f.position.x-r.x)*t;f.position.y=r.y+(f.position.y-r.y)*n;l.update(f.bounds,f.vertices,e.velocity)}if(e.parts.length>1){e.area=a;if(!e.isStatic){i.setMass(e,e.density*a);i.setInertia(e,s)}}e.circleRadius&&(t===n?e.circleRadius*=t:e.circleRadius=null)};
/**
         * Performs a simulation step for the given `body`, including updating position and angle using Verlet integration.
         * @method update
         * @param {body} body
         * @param {number} deltaTime
         * @param {number} timeScale
         * @param {number} correction
         */i.update=function(e,t,n,i){var a=Math.pow(t*n*e.timeScale,2);var s=1-e.frictionAir*n*e.timeScale,u=e.position.x-e.positionPrev.x,f=e.position.y-e.positionPrev.y;e.velocity.x=u*s*i+e.force.x/e.mass*a;e.velocity.y=f*s*i+e.force.y/e.mass*a;e.positionPrev.x=e.position.x;e.positionPrev.y=e.position.y;e.position.x+=e.velocity.x;e.position.y+=e.velocity.y;e.angularVelocity=(e.angle-e.anglePrev)*s*i+e.torque/e.inertia*a;e.anglePrev=e.angle;e.angle+=e.angularVelocity;e.speed=r.magnitude(e.velocity);e.angularSpeed=Math.abs(e.angularVelocity);for(var d=0;d<e.parts.length;d++){var p=e.parts[d];o.translate(p.vertices,e.velocity);if(d>0){p.position.x+=e.velocity.x;p.position.y+=e.velocity.y}if(0!==e.angularVelocity){o.rotate(p.vertices,e.angularVelocity,e.position);c.rotate(p.axes,e.angularVelocity);d>0&&r.rotateAbout(p.position,e.angularVelocity,e.position,p.position)}l.update(p.bounds,p.vertices,e.velocity)}};
/**
         * Applies a force to a body from a given world-space position, including resulting torque.
         * @method applyForce
         * @param {body} body
         * @param {vector} position
         * @param {vector} force
         */i.applyForce=function(e,t,n){e.force.x+=n.x;e.force.y+=n.y;var i={x:t.x-e.position.x,y:t.y-e.position.y};e.torque+=i.x*n.y-i.y*n.x};
/**
         * Returns the sums of the properties of all compound parts of the parent body.
         * @method _totalProperties
         * @private
         * @param {body} body
         * @return {}
         */i._totalProperties=function(e){var t={mass:0,area:0,inertia:0,centre:{x:0,y:0}};for(var n=1===e.parts.length?0:1;n<e.parts.length;n++){var i=e.parts[n],o=Infinity!==i.mass?i.mass:1;t.mass+=o;t.area+=i.area;t.inertia+=i.inertia;t.centre=r.add(t.centre,r.mult(i.position,o))}t.centre=r.div(t.centre,t.mass);return t};
/**
        * Fired when a body starts sleeping (where `this` is the body).
        *
        * @event sleepStart
        * @this {body} The body that has started sleeping
        * @param {} event An event object
        * @param {} event.source The source object of the event
        * @param {} event.name The name of the event
        */
/**
        * Fired when a body ends sleeping (where `this` is the body).
        *
        * @event sleepEnd
        * @this {body} The body that has ended sleeping
        * @param {} event An event object
        * @param {} event.source The source object of the event
        * @param {} event.name The name of the event
        */
/**
         * An integer `Number` uniquely identifying number generated in `Body.create` by `Common.nextId`.
         *
         * @property id
         * @type number
         */
/**
         * A `String` denoting the type of object.
         *
         * @property type
         * @type string
         * @default "body"
         * @readOnly
         */
/**
         * An arbitrary `String` name to help the user identify and manage bodies.
         *
         * @property label
         * @type string
         * @default "Body"
         */
/**
         * An array of bodies that make up this body. 
         * The first body in the array must always be a self reference to the current body instance.
         * All bodies in the `parts` array together form a single rigid compound body.
         * Parts are allowed to overlap, have gaps or holes or even form concave bodies.
         * Parts themselves should never be added to a `World`, only the parent body should be.
         * Use `Body.setParts` when setting parts to ensure correct updates of all properties.
         *
         * @property parts
         * @type body[]
         */
/**
         * An object reserved for storing plugin-specific properties.
         *
         * @property plugin
         * @type {}
         */
/**
         * A self reference if the body is _not_ a part of another body.
         * Otherwise this is a reference to the body that this is a part of.
         * See `body.parts`.
         *
         * @property parent
         * @type body
         */
/**
         * A `Number` specifying the angle of the body, in radians.
         *
         * @property angle
         * @type number
         * @default 0
         */
/**
         * An array of `Vector` objects that specify the convex hull of the rigid body.
         * These should be provided about the origin `(0, 0)`. E.g.
         *
         *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]
         *
         * When passed via `Body.create`, the vertices are translated relative to `body.position` (i.e. world-space, and constantly updated by `Body.update` during simulation).
         * The `Vector` objects are also augmented with additional properties required for efficient collision detection. 
         *
         * Other properties such as `inertia` and `bounds` are automatically calculated from the passed vertices (unless provided via `options`).
         * Concave hulls are not currently supported. The module `Matter.Vertices` contains useful methods for working with vertices.
         *
         * @property vertices
         * @type vector[]
         */
/**
         * A `Vector` that specifies the current world-space position of the body.
         *
         * @property position
         * @type vector
         * @default { x: 0, y: 0 }
         */
/**
         * A `Vector` that specifies the force to apply in the current step. It is zeroed after every `Body.update`. See also `Body.applyForce`.
         *
         * @property force
         * @type vector
         * @default { x: 0, y: 0 }
         */
/**
         * A `Number` that specifies the torque (turning force) to apply in the current step. It is zeroed after every `Body.update`.
         *
         * @property torque
         * @type number
         * @default 0
         */
/**
         * A `Number` that _measures_ the current speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.velocity`). * * @readOnly * @property speed * @type number * @default 0 */ /** * A `Number`
                                            that _measures_ the current angular speed of the body after the last `Body.update`. It is read-only and always positive (it 's the magnitude of `body.angularVelocity`).
         *
         * @readOnly
         * @property angularSpeed
         * @type number
         * @default 0
         */
/**
         * A `Vector` that _measures_ the current velocity of the body after the last `Body.update`. It is read-only. 
         * If you need to modify a body's velocity directly, you should either apply a force or simply change the body 's `position` (as the engine uses position-Verlet integration).
         *
         * @readOnly
         * @property velocity
         * @type vector
         * @default { x: 0, y: 0 }
         */
/**
         * A `Number` that _measures_ the current angular velocity of the body after the last `Body.update`. It is read-only. 
         * If you need to modify a body's angular velocity directly, you should apply a torque or simply change the body 's `angle` (as the engine uses position-Verlet integration).
         *
         * @readOnly
         * @property angularVelocity
         * @type number
         * @default 0
         */
/**
         * A flag that indicates whether a body is considered static. A static body can never change position or angle and is completely fixed.
         * If you need to set a body as static after its creation, you should use `Body.setStatic` as this requires more than just setting this flag.
         *
         * @property isStatic
         * @type boolean
         * @default false
         */
/**
         * A flag that indicates whether a body is a sensor. Sensor triggers collision events, but doesn't react with colliding body physically. * * @property isSensor * @type boolean * @default false */ /** * A flag that indicates whether the body
                                            is considered sleeping. A sleeping body acts similar to a static body, except it is only temporary and can be awoken. * If you need to set a body as sleeping, you should use `Sleeping.set` as this requires more
                                            than just setting this flag. * * @property isSleeping * @type boolean * @default false */ /** * A `Number` that _measures_ the amount of movement a body currently has (a combination of `speed` and `angularSpeed`).
                                            It is read-only and always positive. * It is used and updated by the `Matter.Sleeping` module during simulation to decide if a body has come to rest. * * @readOnly * @property motion * @type number * @default 0
                                            */ /** * A `Number` that defines the number of updates in which this body must have near-zero velocity before it is set as sleeping by the `Matter.Sleeping` module (if sleeping is enabled by the engine). * * @property
                                            sleepThreshold * @type number * @default 60 */ /** * A `Number` that defines the density of the body, that is its mass per unit area. * If you pass the density via `Body.create` the `mass` property is automatically
                                            calculated for you based on the size (area) of the object. * This is generally preferable to simply setting mass and allows for more intuitive definition of materials (e.g. rock has a higher density than wood).
                                            * * @property density * @type number * @default 0.001 */ /** * A `Number` that defines the mass of the body, although it may be more appropriate to specify the `density` property instead. * If you modify this value,
                                            you must also modify the `body.inverseMass` property (`1 / mass`). * * @property mass * @type number */ /** * A `Number` that defines the inverse mass of the body (`1 / mass`). * If you modify this value, you must
                                            also modify the `body.mass` property. * * @property inverseMass * @type number */ /** * A `Number` that defines the moment of inertia (i.e. second moment of area) of the body. * It is automatically calculated from
                                            the given convex hull (`vertices` array) and density in `Body.create`. * If you modify this value, you must also modify the `body.inverseInertia` property (`1 / inertia`). * * @property inertia * @type number */
                                        /** * A `Number` that defines the inverse moment of inertia of the body (`1 / inertia`). * If you modify this value, you must also modify the `body.inertia` property. * * @property inverseInertia * @type number
                                            */ /** * A `Number` that defines the restitution (elasticity) of the body. The value is always positive and is in the range `(0, 1)`. * A value of `0` means collisions may be perfectly inelastic and no bouncing
                                            may occur. * A value of `0.8` means the body may bounce back with approximately 80% of its kinetic energy. * Note that collision response is based on _pairs_ of bodies, and that `restitution` values are _combined_
                                            with the following formula: * * Math.max(bodyA.restitution, bodyB.restitution) * * @property restitution * @type number * @default 0 */ /** * A `Number` that defines the friction of the body. The value is always
                                            positive and is in the range `(0, 1)`. * A value of `0` means that the body may slide indefinitely. * A value of `1` means the body may come to a stop almost instantly after a force is applied. * * The effects of
                                            the value may be non-linear. * High values may be unstable depending on the body. * The engine uses a Coulomb friction model including static and kinetic friction. * Note that collision response is based on _pairs_
                                            of bodies, and that `friction` values are _combined_ with the following formula: * * Math.min(bodyA.friction, bodyB.friction) * * @property friction * @type number * @default 0.1 */ /** * A `Number` that defines
                                            the static friction of the body (in the Coulomb friction model). * A value of `0` means the body will never 'stick' when it is nearly stationary and only dynamic `friction` is used. * The higher the value (e.g.
                                            `10`), the more force it will take to initially get the body moving when nearly stationary. * This value is multiplied with the `friction` property to make it easier to change `friction` and maintain an appropriate
                                            amount of static friction. * * @property frictionStatic * @type number * @default 0.5 */ /** * A `Number` that defines the air friction of the body (air resistance). * A value of `0` means the body will never slow
                                            as it moves through space. * The higher the value, the faster a body slows when moving through space. * The effects of the value are non-linear. * * @property frictionAir * @type number * @default 0.01 */ /** *
                                            An `Object` that specifies the collision filtering properties of this body. * * Collisions between two bodies will obey the following rules: * - If the two bodies have the same non-zero value of `collisionFilter.group`,
                                            * they will always collide if the value is positive, and they will never collide * if the value is negative. * - If the two bodies have different values of `collisionFilter.group` or if one * (or both) of the bodies
                                            has a value of 0, then the category/mask rules apply as follows: * * Each body belongs to a collision category, given by `collisionFilter.category`. This * value is used as a bit field and the category should have
                                            only one bit set, meaning that * the value of this property is a power of two in the range [1, 2^31]. Thus, there are 32 * different collision categories available. * * Each body also defines a collision bitmask,
                                            given by `collisionFilter.mask` which specifies * the categories it collides with (the value is the bitwise AND value of all these categories). * * Using the category/mask rules, two bodies `A` and `B` collide if
                                            each includes the other 's
         * category in its mask, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0`
         * are both true.
         *
         * @property collisionFilter
         * @type object
         */
/**
         * An Integer `Number`, that specifies the collision group this body belongs to.
         * See `body.collisionFilter` for more information.
         *
         * @property collisionFilter.group
         * @type object
         * @default 0
         */
/**
         * A bit field that specifies the collision category this body belongs to.
         * The category value should have only one bit set, for example `0x0001`.
         * This means there are up to 32 unique collision categories available.
         * See `body.collisionFilter` for more information.
         *
         * @property collisionFilter.category
         * @type object
         * @default 1
         */
/**
         * A bit mask that specifies the collision categories this body may collide with.
         * See `body.collisionFilter` for more information.
         *
         * @property collisionFilter.mask
         * @type object
         * @default -1
         */
/**
         * A `Number` that specifies a tolerance on how far a body is allowed to 'sink ' or rotate into other bodies.
         * Avoid changing this value unless you understand the purpose of `slop` in physics engines.
         * The default should generally suffice, although very large bodies may require larger values for stable stacking.
         *
         * @property slop
         * @type number
         * @default 0.05
         */
/**
         * A `Number` that allows per-body time scaling, e.g. a force-field where bodies inside are in slow-motion, while others are at full speed.
         *
         * @property timeScale
         * @type number
         * @default 1
         */
/**
         * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.
         *
         * @property render
         * @type object
         */
/**
         * A flag that indicates if the body should be rendered.
         *
         * @property render.visible
         * @type boolean
         * @default true
         */
/**
         * Sets the opacity to use when rendering.
         *
         * @property render.opacity
         * @type number
         * @default 1
        */
/**
         * An `Object` that defines the sprite properties to use when rendering, if any.
         *
         * @property render.sprite
         * @type object
         */
/**
         * An `String` that defines the path to the image to use as the sprite texture, if any.
         *
         * @property render.sprite.texture
         * @type string
         */
/**
         * A `Number` that defines the scaling in the x-axis for the sprite, if any.
         *
         * @property render.sprite.xScale
         * @type number
         * @default 1
         */
/**
         * A `Number` that defines the scaling in the y-axis for the sprite, if any.
         *
         * @property render.sprite.yScale
         * @type number
         * @default 1
         */
/**
          * A `Number` that defines the offset in the x-axis for the sprite (normalised by texture width).
          *
          * @property render.sprite.xOffset
          * @type number
          * @default 0
          */
/**
          * A `Number` that defines the offset in the y-axis for the sprite (normalised by texture height).
          *
          * @property render.sprite.yOffset
          * @type number
          * @default 0
          */
/**
         * A `Number` that defines the line width to use when rendering the body outline (if a sprite is not defined).
         * A value of `0` means no outline will be rendered.
         *
         * @property render.lineWidth
         * @type number
         * @default 0
         */
/**
         * A `String` that defines the fill style to use when rendering the body (if a sprite is not defined).
         * It is the same as when using a canvas, so it accepts CSS style property values.
         *
         * @property render.fillStyle
         * @type string
         * @default a random colour
         */
/**
         * A `String` that defines the stroke style to use when rendering the body outline (if a sprite is not defined).
         * It is the same as when using a canvas, so it accepts CSS style property values.
         *
         * @property render.strokeStyle
         * @type string
         * @default a random colour
         */
/**
         * An array of unique axis vectors (edge normals) used for collision detection.
         * These are automatically calculated from the given convex hull (`vertices` array) in `Body.create`.
         * They are constantly updated by `Body.update` during the simulation.
         *
         * @property axes
         * @type vector[]
         */
/**
         * A `Number` that _measures_ the area of the body's convex hull, calculated at creation by `Body.create`. * * @property area * @type string * @default */ /** * A `Bounds` object that defines the AABB region for the body. * It is automatically
                                            calculated from the given convex hull (`vertices` array) in `Body.create` and constantly updated by `Body.update` during simulation. * * @property bounds * @type bounds */})()},function(e,t,n){var i={};e.exports=i;var
                                            o=n(4);(function(){i._motionWakeThreshold=.18;i._motionSleepThreshold=.08;i._minBias=.9; /** * Puts bodies to sleep or wakes them up depending on their motion. * @method update * @param {body[]} bodies * @param
                                            {number} timeScale */i.update=function(e,t){var n=t*t*t;for(var o=0;o<e.length;o++){var r=e[o],a=r.speed*r.speed+r.angularSpeed*r.angularSpeed;if(0===r.force.x&&0===r.force.y){var s=Math.min(r.motion,a),l=Math.max(r.motion,a);r.motion=i._minBias*s+(1-i._minBias)*l;if(r.sleepThreshold>0&&r.motion
                                            <i._motionSleepThreshold*n){r.sleepCounter+=1;r.sleepCounter>=r.sleepThreshold&&i.set(r,true)}else r.sleepCounter>0&&(r.sleepCounter-=1)}else i.set(r,false)}}; /** * Given a set of colliding pairs, wakes the sleeping bodies involved. * @method afterCollisions * @param
                                                {pair[]} pairs * @param {number} timeScale */i.afterCollisions=function(e,t){var n=t*t*t;for(var o=0;o
                                                <e.length;o++){var r=e[o];if(r.isActive){var a=r.collision,s=a.bodyA.parent,l=a.bodyB.parent;if(!(s.isSleeping&&l.isSleeping||s.isStatic||l.isStatic)&&(s.isSleeping||l.isSleeping)){var
                                                    c=s.isSleeping&&!s.isStatic?s:l,u=c===s?l:s;!c.isStatic&&u.motion>i._motionWakeThreshold*n&&i.set(c,false)}}}}; /** * Set a body as sleeping or awake. * @method set * @param {body} body * @param {boolean} isSleeping */i.set=function(e,t){var n=e.isSleeping;if(t){e.isSleeping=true;e.sleepCounter=e.sleepThreshold;e.positionImpulse.x=0;e.positionImpulse.y=0;e.positionPrev.x=e.position.x;e.positionPrev.y=e.position.y;e.anglePrev=e.angle;e.speed=0;e.angularSpeed=0;e.motion=0;n||o.trigger(e,"sleepStart")}else{e.isSleeping=false;e.sleepCounter=0;n&&o.trigger(e,"sleepEnd")}}})()},function(e,t,n){var
                                                    i={};e.exports=i;var o=n(3);var r=n(9);(function(){var e=[];var t={overlap:0,axis:null};var n={overlap:0,axis:null}; /** * Creates a new collision record. * @method create * @param {body} bodyA The first
                                                    body part represented by the collision record * @param {body} bodyB The second body part represented by the collision record * @return {collision} A new collision record */i.create=function(e,t){return{pair:null,collided:false,bodyA:e,bodyB:t,parentA:e.parent,parentB:t.parent,depth:0,normal:{x:0,y:0},tangent:{x:0,y:0},penetration:{x:0,y:0},supports:[]}};
                                                    /** * Detect collision between two bodies. * @method collides * @param {body} bodyA * @param {body} bodyB * @param {pairs} [pairs] Optionally reuse collision records from existing pairs. * @return {collision|null}
                                                    A collision record if detected, otherwise null */i.collides=function(e,a,s){i._overlapAxes(t,e.vertices,a.vertices,e.axes);if(t.overlap
                                                    <=0)return null;i._overlapAxes(n,a.vertices,e.vertices,a.axes);if(n.overlap<=0)return null;var l,c=s&&s.table[r.id(e,a)];if(c)l=c.collision;else{l=i.create(e,a);l.collided=true;l.bodyA=e.id<a.id?e:a;l.bodyB=e.id<a.id?a:e;l.parentA=l.bodyA.parent;l.parentB=l.bodyB.parent}e=l.bodyA;a=l.bodyB;var
                                                        u;u=t.overlap<n.overlap?t:n;var f=l.normal,d=l.supports,p=u.axis,v=p.x,y=p.y;if(v*(a.position.x-e.position.x)+y*(a.position.y-e.position.y)<0){f.x=v;f.y=y}else{f.x=-v;f.y=-y}l.tangent.x=-f.y;l.tangent.y=f.x;l.depth=u.overlap;l.penetration.x=f.x*l.depth;l.penetration.y=f.y*l.depth;var
                                                        m=i._findSupports(e,a,f,1),g=0;o.contains(e.vertices,m[0])&&(d[g++]=m[0]);o.contains(e.vertices,m[1])&&(d[g++]=m[1]);if(g<2){var x=i._findSupports(a,e,f,-1);o.contains(a.vertices,x[0])&&(d[g++]=x[0]);g<2&&o.contains(a.vertices,x[1])&&(d[g++]=x[1])}0===g&&(d[g++]=m[0]);d.length=g;return
                                                        l}; /** * Find the overlap between two sets of vertices. * @method _overlapAxes * @private * @param {object} result * @param {vertices} verticesA * @param {vertices} verticesB * @param {axes} axes */i._overlapAxes=function(e,t,n,i){var
                                                        o,r,a,s,l,c,u=t.length,f=n.length,d=t[0].x,p=t[0].y,v=n[0].x,y=n[0].y,m=i.length,g=Number.MAX_VALUE,x=0;for(l=0;l<m;l++){var h=i[l],b=h.x,S=h.y,w=d*b+p*S,_=v*b+y*S,A=w,P=_;for(c=1;c<u;c+=1){s=t[c].x*b+t[c].y*S;s>A?A=s:s
                                                        <w&&(w=s)}for(c=1;c<f;c+=1){s=n[c].x*b+n[c].y*S;s>P?P=s:s
                                                            <_&&(_=s)}r=A-_;a=P-w;o=r<a?r:a;if(o<g){g=o;x=l;if(o<=0)break}}e.axis=i[x];e.overlap=g}; /** * Projects vertices on an axis and returns an interval. * @method _projectToAxis * @private * @param
                                                                {} projection * @param {} vertices * @param {} axis */i._projectToAxis=function(e,t,n){var i=t[0].x*n.x+t[0].y*n.y,o=i;for(var r=1;r<t.length;r+=1){var a=t[r].x*n.x+t[r].y*n.y;a>o?o=a:a
                                                                <i&&(i=a)}e.min=i;e.max=o}; /** * Finds supporting vertices given two bodies along a given direction using hill-climbing. * @method _findSupports * @private * @param {body} bodyA * @param
                                                                    {body} bodyB * @param {vector} normal * @param {number} direction * @return [vector] */i._findSupports=function(t,n,i,o){var r,a,s,l,c,u=n.vertices,f=u.length,d=t.position.x,p=t.position.y,v=i.x*o,y=i.y*o,m=Number.MAX_VALUE;for(c=0;c<f;c+=1){a=u[c];l=v*(d-a.x)+y*(p-a.y);if(l<m){m=l;r=a}}s=u[(f+r.index-1)%f];m=v*(d-s.x)+y*(p-s.y);a=u[(r.index+1)%f];if(v*(d-a.x)+y*(p-a.y)<m){e[0]=r;e[1]=a;return
                                                                    e}e[0]=r;e[1]=s;return e}; /** * A reference to the pair using this collision record, if there is one. * * @property pair * @type {pair|null} * @default null */ /** * A flag that indicates
                                                                    if the bodies were colliding when the collision was last updated. * * @property collided * @type boolean * @default false */ /** * The first body part represented by the collision (see also
                                                                    `collision.parentA`). * * @property bodyA * @type body */ /** * The second body part represented by the collision (see also `collision.parentB`). * * @property bodyB * @type body */ /** *
                                                                    The first body represented by the collision (i.e. `collision.bodyA.parent`). * * @property parentA * @type body */ /** * The second body represented by the collision (i.e. `collision.bodyB.parent`).
                                                                    * * @property parentB * @type body */ /** * A `Number` that represents the minimum separating distance between the bodies along the collision normal. * * @readOnly * @property depth * @type
                                                                    number * @default 0 */ /** * A normalised `Vector` that represents the direction between the bodies that provides the minimum separating distance. * * @property normal * @type vector * @default
                                                                    { x: 0, y: 0 } */ /** * A normalised `Vector` that is the tangent direction to the collision normal. * * @property tangent * @type vector * @default { x: 0, y: 0 } */ /** * A `Vector` that
                                                                    represents the direction and depth of the collision. * * @property penetration * @type vector * @default { x: 0, y: 0 } */ /** * An array of body vertices that represent the support points
                                                                    in the collision. * These are the deepest vertices (along the collision normal) of each body that are contained by the other body 's vertices.
         *
         * @property supports
         * @type vector[]
         * @default []
         */})()},function(e,t,n){var i={};e.exports=i;var o=n(17);(function(){
/**
         * Creates a pair.
         * @method create
         * @param {collision} collision
         * @param {number} timestamp
         * @return {pair} A new pair
         */
i.create=function(e,t){var n=e.bodyA,o=e.bodyB;var r={id:i.id(n,o),bodyA:n,bodyB:o,collision:e,contacts:[],activeContacts:[],separation:0,isActive:true,confirmedActive:true,isSensor:n.isSensor||o.isSensor,timeCreated:t,timeUpdated:t,inverseMass:0,friction:0,frictionStatic:0,restitution:0,slop:0};i.update(r,e,t);return r};
/**
         * Updates a pair given a collision.
         * @method update
         * @param {pair} pair
         * @param {collision} collision
         * @param {number} timestamp
         */i.update=function(e,t,n){var i=e.contacts,r=t.supports,a=e.activeContacts,s=t.parentA,l=t.parentB,c=s.vertices.length;e.isActive=true;e.timeUpdated=n;e.collision=t;e.separation=t.depth;e.inverseMass=s.inverseMass+l.inverseMass;e.friction=s.friction<l.friction?s.friction:l.friction;e.frictionStatic=s.frictionStatic>l.frictionStatic?s.frictionStatic:l.frictionStatic;e.restitution=s.restitution>l.restitution?s.restitution:l.restitution;e.slop=s.slop>l.slop?s.slop:l.slop;t.pair=e;a.length=0;for(var u=0;u<r.length;u++){var f=r[u],d=f.body===s?f.index:c+f.index,p=i[d];p?a.push(p):a.push(i[d]=o.create(f))}};
/**
         * Set a pair as active or inactive.
         * @method setActive
         * @param {pair} pair
         * @param {bool} isActive
         * @param {number} timestamp
         */i.setActive=function(e,t,n){if(t){e.isActive=true;e.timeUpdated=n}else{e.isActive=false;e.activeContacts.length=0}};
/**
         * Get the id for the given pair.
         * @method id
         * @param {body} bodyA
         * @param {body} bodyB
         * @return {string} Unique pairId
         */i.id=function(e,t){return e.id<t.id?"A"+e.id+"B"+t.id:"A"+t.id+"B"+e.id}})()},function(e,t,n){var i={};e.exports=i;var o=n(3);var r=n(2);var a=n(7);var s=n(1);var l=n(11);var c=n(0);(function(){i._warming=.4;i._torqueDampen=1;i._minLength=1e-6;
/**
         * Creates a new constraint.
         * All properties have default values, and many are pre-calculated automatically based on other properties.
         * To simulate a revolute constraint (or pin joint) set `length: 0` and a high `stiffness` value (e.g. `0.7` or above).
         * If the constraint is unstable, try lowering the `stiffness` value and / or increasing `engine.constraintIterations`.
         * For compound bodies, constraints must be applied to the parent body (not one of its parts).
         * See the properties section below for detailed information on what you can pass via the `options` object.
         * @method create
         * @param {} options
         * @return {constraint} constraint
         */i.create=function(e){var t=e;t.bodyA&&!t.pointA&&(t.pointA={x:0,y:0});t.bodyB&&!t.pointB&&(t.pointB={x:0,y:0});var n=t.bodyA?r.add(t.bodyA.position,t.pointA):t.pointA,i=t.bodyB?r.add(t.bodyB.position,t.pointB):t.pointB,o=r.magnitude(r.sub(n,i));t.length="undefined"!==typeof t.length?t.length:o;t.id=t.id||c.nextId();t.label=t.label||"Constraint";t.type="constraint";t.stiffness=t.stiffness||(t.length>0?1:.7);t.damping=t.damping||0;t.angularStiffness=t.angularStiffness||0;t.angleA=t.bodyA?t.bodyA.angle:t.angleA;t.angleB=t.bodyB?t.bodyB.angle:t.angleB;t.plugin={};var a={visible:true,lineWidth:2,strokeStyle:"#ffffff",type:"line",anchors:true};if(0===t.length&&t.stiffness>.1){a.type="pin";a.anchors=false}else t.stiffness<.9&&(a.type="spring");t.render=c.extend(a,t.render);return t};
/**
         * Prepares for solving by constraint warming.
         * @private
         * @method preSolveAll
         * @param {body[]} bodies
         */i.preSolveAll=function(e){for(var t=0;t<e.length;t+=1){var n=e[t],i=n.constraintImpulse;if(!(n.isStatic||0===i.x&&0===i.y&&0===i.angle)){n.position.x+=i.x;n.position.y+=i.y;n.angle+=i.angle}}};
/**
         * Solves all constraints in a list of collisions.
         * @private
         * @method solveAll
         * @param {constraint[]} constraints
         * @param {number} timeScale
         */i.solveAll=function(e,t){for(var n=0;n<e.length;n+=1){var o=e[n],r=!o.bodyA||o.bodyA&&o.bodyA.isStatic,a=!o.bodyB||o.bodyB&&o.bodyB.isStatic;(r||a)&&i.solve(e[n],t)}for(n=0;n<e.length;n+=1){o=e[n];r=!o.bodyA||o.bodyA&&o.bodyA.isStatic;a=!o.bodyB||o.bodyB&&o.bodyB.isStatic;r||a||i.solve(e[n],t)}};
/**
         * Solves a distance constraint with Gauss-Siedel method.
         * @private
         * @method solve
         * @param {constraint} constraint
         * @param {number} timeScale
         */i.solve=function(e,t){var n=e.bodyA,o=e.bodyB,a=e.pointA,s=e.pointB;if(n||o){if(n&&!n.isStatic){r.rotate(a,n.angle-e.angleA,a);e.angleA=n.angle}if(o&&!o.isStatic){r.rotate(s,o.angle-e.angleB,s);e.angleB=o.angle}var l=a,c=s;n&&(l=r.add(n.position,a));o&&(c=r.add(o.position,s));if(l&&c){var u=r.sub(l,c),f=r.magnitude(u);f<i._minLength&&(f=i._minLength);var d,p,v,y,m,g=(f-e.length)/f,x=e.stiffness<1?e.stiffness*t:e.stiffness,h=r.mult(u,g*x),b=(n?n.inverseMass:0)+(o?o.inverseMass:0),S=(n?n.inverseInertia:0)+(o?o.inverseInertia:0),w=b+S;if(e.damping){var _=r.create();v=r.div(u,f);m=r.sub(o&&r.sub(o.position,o.positionPrev)||_,n&&r.sub(n.position,n.positionPrev)||_);y=r.dot(v,m)}if(n&&!n.isStatic){p=n.inverseMass/b;n.constraintImpulse.x-=h.x*p;n.constraintImpulse.y-=h.y*p;n.position.x-=h.x*p;n.position.y-=h.y*p;if(e.damping){n.positionPrev.x-=e.damping*v.x*y*p;n.positionPrev.y-=e.damping*v.y*y*p}d=r.cross(a,h)/w*i._torqueDampen*n.inverseInertia*(1-e.angularStiffness);n.constraintImpulse.angle-=d;n.angle-=d}if(o&&!o.isStatic){p=o.inverseMass/b;o.constraintImpulse.x+=h.x*p;o.constraintImpulse.y+=h.y*p;o.position.x+=h.x*p;o.position.y+=h.y*p;if(e.damping){o.positionPrev.x+=e.damping*v.x*y*p;o.positionPrev.y+=e.damping*v.y*y*p}d=r.cross(s,h)/w*i._torqueDampen*o.inverseInertia*(1-e.angularStiffness);o.constraintImpulse.angle+=d;o.angle+=d}}}};
/**
         * Performs body updates required after solving constraints.
         * @private
         * @method postSolveAll
         * @param {body[]} bodies
         */i.postSolveAll=function(e){for(var t=0;t<e.length;t++){var n=e[t],c=n.constraintImpulse;if(!(n.isStatic||0===c.x&&0===c.y&&0===c.angle)){a.set(n,false);for(var u=0;u<n.parts.length;u++){var f=n.parts[u];o.translate(f.vertices,c);if(u>0){f.position.x+=c.x;f.position.y+=c.y}if(0!==c.angle){o.rotate(f.vertices,c.angle,n.position);l.rotate(f.axes,c.angle);u>0&&r.rotateAbout(f.position,c.angle,n.position,f.position)}s.update(f.bounds,f.vertices,n.velocity)}c.angle*=i._warming;c.x*=i._warming;c.y*=i._warming}}};
/**
         * Returns the world-space position of `constraint.pointA`, accounting for `constraint.bodyA`.
         * @method pointAWorld
         * @param {constraint} constraint
         * @returns {vector} the world-space position
         */i.pointAWorld=function(e){return{x:(e.bodyA?e.bodyA.position.x:0)+e.pointA.x,y:(e.bodyA?e.bodyA.position.y:0)+e.pointA.y}};
/**
         * Returns the world-space position of `constraint.pointB`, accounting for `constraint.bodyB`.
         * @method pointBWorld
         * @param {constraint} constraint
         * @returns {vector} the world-space position
         */i.pointBWorld=function(e){return{x:(e.bodyB?e.bodyB.position.x:0)+e.pointB.x,y:(e.bodyB?e.bodyB.position.y:0)+e.pointB.y}};
/**
         * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.
         *
         * @property id
         * @type number
         */
/**
         * A `String` denoting the type of object.
         *
         * @property type
         * @type string
         * @default "constraint"
         * @readOnly
         */
/**
         * An arbitrary `String` name to help the user identify and manage bodies.
         *
         * @property label
         * @type string
         * @default "Constraint"
         */
/**
         * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.
         *
         * @property render
         * @type object
         */
/**
         * A flag that indicates if the constraint should be rendered.
         *
         * @property render.visible
         * @type boolean
         * @default true
         */
/**
         * A `Number` that defines the line width to use when rendering the constraint outline.
         * A value of `0` means no outline will be rendered.
         *
         * @property render.lineWidth
         * @type number
         * @default 2
         */
/**
         * A `String` that defines the stroke style to use when rendering the constraint outline.
         * It is the same as when using a canvas, so it accepts CSS style property values.
         *
         * @property render.strokeStyle
         * @type string
         * @default a random colour
         */
/**
         * A `String` that defines the constraint rendering type. 
         * The possible values are 'line ', 'pin ', 'spring '.
         * An appropriate render type will be automatically chosen unless one is given in options.
         *
         * @property render.type
         * @type string
         * @default 'line '
         */
/**
         * A `Boolean` that defines if the constraint's anchor points should be rendered. * * @property render.anchors * @type boolean * @default true */ /** * The first possible `Body` that this constraint is attached to. * * @property bodyA * @type
                                                                    body * @default null */ /** * The second possible `Body` that this constraint is attached to. * * @property bodyB * @type body * @default null */ /** * A `Vector` that specifies the offset
                                                                    of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position. * * @property pointA * @type vector * @default { x: 0, y: 0 } */ /** * A `Vector` that
                                                                    specifies the offset of the constraint from center of the `constraint.bodyB` if defined, otherwise a world-space position. * * @property pointB * @type vector * @default { x: 0, y: 0 } */
                                                                /** * A `Number` that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`. * A value of `1` means the constraint should be very
                                                                    stiff. * A value of `0.2` means the constraint acts like a soft spring. * * @property stiffness * @type number * @default 1 */ /** * A `Number` that specifies the damping of the constraint,
                                                                    * i.e. the amount of resistance applied to each body based on their velocities to limit the amount of oscillation. * Damping will only be apparent when the constraint also has a very low
                                                                    `stiffness`. * A value of `0.1` means the constraint will apply heavy damping, resulting in little to no oscillation. * A value of `0` means the constraint will apply no damping. * * @property
                                                                    damping * @type number * @default 0 */ /** * A `Number` that specifies the target resting length of the constraint. * It is calculated automatically in `Constraint.create` from initial positions
                                                                    of the `constraint.bodyA` and `constraint.bodyB`. * * @property length * @type number */ /** * An object reserved for storing plugin-specific properties. * * @property plugin * @type {} */})()},function(e,t,n){var
                                                                    i={};e.exports=i;var o=n(2);var r=n(0);(function(){ /** * Creates a new set of axes from the given vertices. * @method fromVertices * @param {vertices} vertices * @return {axes} A new axes
                                                                    from the given vertices */ i.fromVertices=function(e){var t={};for(var n=0;n<e.length;n++){var i=(n+1)%e.length,a=o.normalise({x:e[i].y-e[n].y,y:e[n].x-e[i].x}),s=0===a.y?Infinity:a.x/a.y;s=s.toFixed(3).toString();t[s]=a}return
                                                                    r.values(t)}; /** * Rotates a set of axes by the given angle. * @method rotate * @param {axes} axes * @param {number} angle */i.rotate=function(e,t){if(0!==t){var n=Math.cos(t),i=Math.sin(t);for(var
                                                                    o=0;o<e.length;o++){var r,a=e[o];r=a.x*n-a.y*i;a.y=a.x*i+a.y*n;a.x=r}}}})()},function(e,t,n){var i={};e.exports=i;var o=n(3);var r=n(0);var a=n(6);var s=n(1);var l=n(2);(function(){ /** *
                                                                    Creates a new rigid body model with a rectangle hull. * The options parameter is an object that specifies any properties you wish to override the defaults. * See the properties section of
                                                                    the `Matter.Body` module for detailed information on what you can pass via the `options` object. * @method rectangle * @param {number} x * @param {number} y * @param {number} width * @param
                                                                    {number} height * @param {object} [options] * @return {body} A new rectangle body */ i.rectangle=function(e,t,n,i,s){s=s||{};var l={label: "Rectangle Body",position:{x:e,y:t},vertices:o.fromPath(
                                                                    "L 0 0 L "+n+ " 0 L "+n+ " "+i+ " L 0 "+i)};if(s.chamfer){var c=s.chamfer;l.vertices=o.chamfer(l.vertices,c.radius,c.quality,c.qualityMin,c.qualityMax);delete s.chamfer}return a.create(r.extend({},l,s))};
                                                                /** * Creates a new rigid body model with a trapezoid hull. * The options parameter is an object that specifies any properties you wish to override the defaults. * See the properties section
                                                                    of the `Matter.Body` module for detailed information on what you can pass via the `options` object. * @method trapezoid * @param {number} x * @param {number} y * @param {number} width * @param
                                                                    {number} height * @param {number} slope * @param {object} [options] * @return {body} A new trapezoid body */i.trapezoid=function(e,t,n,i,s,l){l=l||{};s*=.5;var c=(1-2*s)*n;var u,f=n*s,d=f+c,p=d+f;u=s<.5?
                                                                    "L 0 0 L "+f+ " "+-i+ " L "+d+ " "+-i+ " L "+p+ " 0": "L 0 0 L "+d+ " "+-i+ " L "+p+ " 0";var v={label: "Trapezoid Body",position:{x:e,y:t},vertices:o.fromPath(u)};if(l.chamfer){var y=l.chamfer;v.vertices=o.chamfer(v.vertices,y.radius,y.quality,y.qualityMin,y.qualityMax);delete
                                                                    l.chamfer}return a.create(r.extend({},v,l))}; /** * Creates a new rigid body model with a circle hull. * The options parameter is an object that specifies any properties you wish to override
                                                                    the defaults. * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object. * @method circle * @param {number} x * @param
                                                                    {number} y * @param {number} radius * @param {object} [options] * @param {number} [maxSides] * @return {body} A new circle body */i.circle=function(e,t,n,o,a){o=o||{};var s={label:
                                                                    "Circle Body",circleRadius:n};a=a||25;var l=Math.ceil(Math.max(10,Math.min(a,n)));l%2===1&&(l+=1);return i.polygon(e,t,l,n,r.extend({},s,o))}; /** * Creates a new rigid body model with a regular polygon
                                                                    hull with the given number of sides. * The options parameter is an object that specifies any properties you wish to override the defaults. * See the properties section of the `Matter.Body`
                                                                    module for detailed information on what you can pass via the `options` object. * @method polygon * @param {number} x * @param {number} y * @param {number} sides * @param {number} radius *
                                                                    @param {object} [options] * @return {body} A new regular polygon body */i.polygon=function(e,t,n,s,l){l=l||{};if(n<3)return i.circle(e,t,s,l);var c=2*Math.PI/n,u="" ,f=.5*c;for(var d=0;d<n;d+=1){var
                                                                    p=f+d*c,v=Math.cos(p)*s,y=Math.sin(p)*s;u+="L " +v.toFixed(3)+ " "+y.toFixed(3)+ " "}var m={label: "Polygon Body",position:{x:e,y:t},vertices:o.fromPath(u)};if(l.chamfer){var g=l.chamfer;m.vertices=o.chamfer(m.vertices,g.radius,g.quality,g.qualityMin,g.qualityMax);delete
                                                                    l.chamfer}return a.create(r.extend({},m,l))}; /** * Utility to create a compound body based on set(s) of vertices. * * _Note:_ To optionally enable automatic concave vertices decomposition
                                                                    the [poly-decomp](https://github.com/schteppe/poly-decomp.js) * package must be first installed and provided see `Common.setDecomp`, otherwise the convex hull of each vertex set will be used.
                                                                    * * The resulting vertices are reorientated about their centre of mass, * and offset such that `body.position` corresponds to this point. * * The resulting offset may be found if needed by
                                                                    subtracting `body.bounds` from the original input bounds. * To later move the centre of mass see `Body.setCentre`. * * Note that automatic conconcave decomposition results are not always
                                                                    optimal. * For best results, simplify the input vertices as much as possible first. * By default this function applies some addtional simplification to help. * * Some outputs may also require
                                                                    further manual processing afterwards to be robust. * In particular some parts may need to be overlapped to avoid collision gaps. * Thin parts and sharp points should be avoided or removed
                                                                    where possible. * * The options parameter object specifies any `Matter.Body` properties you wish to override the defaults. * * See the properties section of the `Matter.Body` module for detailed
                                                                    information on what you can pass via the `options` object. * @method fromVertices * @param {number} x * @param {number} y * @param {array} vertexSets One or more arrays of vertex points e.g.
                                                                    `[[{ x: 0, y: 0 }...], ...]`. * @param {object} [options] The body options. * @param {bool} [flagInternal=false] Optionally marks internal edges with `isInternal`. * @param {number} [removeCollinear=0.01]
                                                                    Threshold when simplifying vertices along the same edge. * @param {number} [minimumArea=10] Threshold when removing small parts. * @param {number} [removeDuplicatePoints=0.01] Threshold when
                                                                    simplifying nearby vertices. * @return {body} */i.fromVertices=function(e,t,n,i,c,u,f,d){var p,v,y,m,g,x,h,b,S,w,_,A=r.getDecomp();p=Boolean(A&&A.quickDecomp);i=i||{};y=[];c="undefined" !==typeof
                                                                    c&&c;u="undefined" !==typeof u?u:.01;f="undefined" !==typeof f?f:10;d="undefined" !==typeof d?d:.01;r.isArray(n[0])||(n=[n]);for(w=0;w<n.length;w+=1){x=n[w];m=o.isConvex(x);g=!m;g&&!p&&r.warnOnce(
                                                                    "Bodies.fromVertices: Install the 'poly-decomp' library and use Common.setDecomp or provide 'decomp' as a global to decompose concave vertices.");if(m||!p){x=m?o.clockwiseSort(x):o.hull(x);y.push({position:{x:e,y:t},vertices:x})}else{var P=x.map((function(e){return[e.x,e.y]}));A.makeCCW(P);false!==u&&A.removeCollinearPoints(P,u);false!==d&&A.removeDuplicatePoints&&A.removeDuplicatePoints(P,d);var
                                                                    C=A.quickDecomp(P);for(h=0;h<C.length;h++){var k=C[h];var M=k.map((function(e){return{x:e[0],y:e[1]}}));f>0&&o.area(M)
                                                                    <f||y.push({position:o.centre(M),vertices:M})}}}for(h=0;h<y.length;h++)y[h]=a.create(r.extend(y[h],i));if(c){var B=5;for(h=0;h<y.length;h++){var I=y[h];for(b=h+1;b<y.length;b++){var
                                                                        T=y[b];if(s.overlaps(I.bounds,T.bounds)){var R=I.vertices,E=T.vertices;for(S=0;S<I.vertices.length;S++)for(_=0;_<T.vertices.length;_++){var V=l.magnitudeSquared(l.sub(R[(S+1)%R.length],E[_])),L=l.magnitudeSquared(l.sub(R[S],E[(_+1)%E.length]));if(V<B&&L<B){R[S].isInternal=true;E[_].isInternal=true}}}}}}if(y.length>1){v=a.create(r.extend({parts:y.slice(0)},i));a.setPosition(v,{x:e,y:t});return v}return y[0]}})()},function(e,t,n){var i={};e.exports=i;var o=n(0);(function(){ /** * Creates a mouse
                                                                        input. * @method create * @param {HTMLElement} element * @return {mouse} A new mouse */ i.create=function(e){var t={};e||o.log("Mouse.create: element was undefined, defaulting to
                                                                        document.body","warn");t.element=e||document.body;t.absolute={x:0,y:0};t.position={x:0,y:0};t.mousedownPosition={x:0,y:0};t.mouseupPosition={x:0,y:0};t.offset={x:0,y:0};t.scale={x:1,y:1};t.wheelDelta=0;t.button=-1;t.pixelRatio=parseInt(t.element.getAttribute("data-pixel-ratio"),10)||1;t.sourceEvents={mousemove:null,mousedown:null,mouseup:null,mousewheel:null};t.mousemove=function(e){var
                                                                        n=i._getRelativeMousePosition(e,t.element,t.pixelRatio),o=e.changedTouches;if(o){t.button=0;e.preventDefault()}t.absolute.x=n.x;t.absolute.y=n.y;t.position.x=t.absolute.x*t.scale.x+t.offset.x;t.position.y=t.absolute.y*t.scale.y+t.offset.y;t.sourceEvents.mousemove=e};t.mousedown=function(e){var
                                                                        n=i._getRelativeMousePosition(e,t.element,t.pixelRatio),o=e.changedTouches;if(o){t.button=0;e.preventDefault()}else t.button=e.button;t.absolute.x=n.x;t.absolute.y=n.y;t.position.x=t.absolute.x*t.scale.x+t.offset.x;t.position.y=t.absolute.y*t.scale.y+t.offset.y;t.mousedownPosition.x=t.position.x;t.mousedownPosition.y=t.position.y;t.sourceEvents.mousedown=e};t.mouseup=function(e){var
                                                                        n=i._getRelativeMousePosition(e,t.element,t.pixelRatio),o=e.changedTouches;o&&e.preventDefault();t.button=-1;t.absolute.x=n.x;t.absolute.y=n.y;t.position.x=t.absolute.x*t.scale.x+t.offset.x;t.position.y=t.absolute.y*t.scale.y+t.offset.y;t.mouseupPosition.x=t.position.x;t.mouseupPosition.y=t.position.y;t.sourceEvents.mouseup=e};t.mousewheel=function(e){t.wheelDelta=Math.max(-1,Math.min(1,e.wheelDelta||-e.detail));e.preventDefault()};i.setElement(t,t.element);return
                                                                        t}; /** * Sets the element the mouse is bound to (and relative to). * @method setElement * @param {mouse} mouse * @param {HTMLElement} element */i.setElement=function(e,t){e.element=t;t.addEventListener("mousemove",e.mousemove);t.addEventListener("mousedown",e.mousedown);t.addEventListener("mouseup",e.mouseup);t.addEventListener("mousewheel",e.mousewheel);t.addEventListener("DOMMouseScroll",e.mousewheel);t.addEventListener("touchmove",e.mousemove);t.addEventListener("touchstart",e.mousedown);t.addEventListener("touchend",e.mouseup)};
                                                                        /** * Clears all captured source events. * @method clearSourceEvents * @param {mouse} mouse */i.clearSourceEvents=function(e){e.sourceEvents.mousemove=null;e.sourceEvents.mousedown=null;e.sourceEvents.mouseup=null;e.sourceEvents.mousewheel=null;e.wheelDelta=0};
                                                                        /** * Sets the mouse position offset. * @method setOffset * @param {mouse} mouse * @param {vector} offset */i.setOffset=function(e,t){e.offset.x=t.x;e.offset.y=t.y;e.position.x=e.absolute.x*e.scale.x+e.offset.x;e.position.y=e.absolute.y*e.scale.y+e.offset.y};
                                                                        /** * Sets the mouse position scale. * @method setScale * @param {mouse} mouse * @param {vector} scale */i.setScale=function(e,t){e.scale.x=t.x;e.scale.y=t.y;e.position.x=e.absolute.x*e.scale.x+e.offset.x;e.position.y=e.absolute.y*e.scale.y+e.offset.y};
                                                                        /** * Gets the mouse position relative to an element given a screen pixel ratio. * @method _getRelativeMousePosition * @private * @param {} event * @param {} element * @param {number}
                                                                        pixelRatio * @return {} */i._getRelativeMousePosition=function(e,t,n){var i,o,r=t.getBoundingClientRect(),a=document.documentElement||document.body.parentNode||document.body,s=void
                                                                        0!==window.pageXOffset?window.pageXOffset:a.scrollLeft,l=void 0!==window.pageYOffset?window.pageYOffset:a.scrollTop,c=e.changedTouches;if(c){i=c[0].pageX-r.left-s;o=c[0].pageY-r.top-l}else{i=e.pageX-r.left-s;o=e.pageY-r.top-l}return{x:i/(t.clientWidth/(t.width||t.clientWidth)*n),y:o/(t.clientHeight/(t.height||t.clientHeight)*n)}}})()},function(e,t,n){var
                                                                        i={};e.exports=i;var o=n(0);var r=n(8);(function(){ /** * Creates a new collision detector. * @method create * @param {} options * @return {detector} A new collision detector */ i.create=function(e){var
                                                                        t={bodies:[],pairs:null};return o.extend(t,e)}; /** * Sets the list of bodies in the detector. * @method setBodies * @param {detector} detector * @param {body[]} bodies */i.setBodies=function(e,t){e.bodies=t.slice(0)};
                                                                        /** * Clears the detector including its list of bodies. * @method clear * @param {detector} detector */i.clear=function(e){e.bodies=[]}; /** * Efficiently finds all collisions among
                                                                        all the bodies in `detector.bodies` using a broadphase algorithm. * * _Note:_ The specific ordering of collisions returned is not guaranteed between releases and may change for performance
                                                                        reasons. * If a specific ordering is required then apply a sort to the resulting array. * @method collisions * @param {detector} detector * @return {collision[]} collisions */i.collisions=function(e){var
                                                                        t,n,o=[],a=e.pairs,s=e.bodies,l=s.length,c=i.canCollide,u=r.collides;s.sort(i._compareBoundsX);for(t=0;t
                                                                        <l;t++){var f=s[t],d=f.bounds,p=f.bounds.max.x,v=f.bounds.max.y,y=f.bounds.min.y,m=f.isStatic||f.isSleeping,g=f.parts.length,x=1===g;for(n=t+1;n<l;n++){var
                                                                            h=s[n],b=h.bounds;if(b.min.x>p)break;if(!(v
                                                                            <b.min.y||y>b.max.y)&&((!m||!h.isStatic&&!h.isSleeping)&&c(f.collisionFilter,h.collisionFilter))){var S=h.parts.length;if(x&&1===S){var w=u(f,h,a);w&&o.push(w)}else{var _=g>1?1:0,A=S>1?1:0;for(var
                                                                                P=_;P
                                                                                <g;P++){var C=f.parts[P];d=C.bounds;for(var k=A;k<S;k++){var M=h.parts[k];b=M.bounds;if(!(d.min.x>b.max.x||d.max.x
                                                                                    <b.min.x||d.max.y<b.min.y||d.min.y>b.max.y)){w=u(C,M,a);w&&o.push(w)}}}}}}}return o}; /** * Returns `true` if both supplied collision filters will allow a collision to occur. * See `body.collisionFilter`
                                                                                        for more information. * @method canCollide * @param {} filterA * @param {} filterB * @return {bool} `true` if collision can occur */i.canCollide=function(e,t){return
                                                                                        e.group===t.group&&0!==e.group?e.group>0:0!==(e.mask&t.category)&&0!==(t.mask&e.category)}; /** * The comparison function used in the broadphase algorithm. * Returns
                                                                                        the signed delta of the bodies bounds on the x-axis. * @private * @method _sortCompare * @param {body} bodyA * @param {body} bodyB * @return {number} The signed delta
                                                                                        used for sorting */i._compareBoundsX=function(e,t){return e.bounds.min.x-t.bounds.min.x}; /** * The array of `Matter.Body` between which the detector finds collisions.
                                                                                        * * _Note:_ The order of bodies in this array _is not fixed_ and will be continually managed by the detector. * @property bodies * @type body[] * @default [] */ /**
                                                                                        * Optional. A `Matter.Pairs` object from which previous collision objects may be reused. Intended for internal `Matter.Engine` usage. * @property pairs * @type {pairs|null}
                                                                                        * @default null */})()},function(e,t,n){var i={};e.exports=i;var o=n(0);(function(){i._registry={}; /** * Registers a plugin object so it can be resolved later by
                                                                                        name. * @method register * @param plugin {} The plugin to register. * @return {object} The plugin. */i.register=function(e){i.isPlugin(e)||o.warn("Plugin.register:",i.toString(e),"does
                                                                                        not implement all required fields.");if(e.name in i._registry){var t=i._registry[e.name],n=i.versionParse(e.version).number,r=i.versionParse(t.version).number;if(n>r){o.warn("Plugin.register:",i.toString(t),"was
                                                                                        upgraded to",i.toString(e));i._registry[e.name]=e}else n
                                                                                        <r?o.warn( "Plugin.register:",i.toString(t), "can not be downgraded to",i.toString(e)):e!==t&&o.warn(
                                                                                            "Plugin.register:",i.toString(e), "is already registered to different plugin object")}else i._registry[e.name]=e;return e}; /** * Resolves a dependency to a plugin object from the
                                                                                            registry if it exists. * The `dependency` may contain a version, but only the name matters when resolving. * @method resolve * @param dependency {string} The dependency.
                                                                                            * @return {object} The plugin if resolved, otherwise `undefined`. */i.resolve=function(e){return i._registry[i.dependencyParse(e).name]}; /** * Returns a pretty printed
                                                                                            plugin name and version. * @method toString * @param plugin {} The plugin. * @return {string} Pretty printed plugin name and version. */i.toString=function(e){return
                                                                                            "string"===typeof e?e:(e.name|| "anonymous")+ "@"+(e.version||e.range|| "0.0.0")}; /** * Returns `true` if the object meets the minimum standard to be considered a plugin.
                                                                                            * This means it must define the following properties: * - `name` * - `version` * - `install` * @method isPlugin * @param obj {} The obj to test. * @return {boolean}
                                                                                            `true` if the object can be considered a plugin otherwise `false`. */i.isPlugin=function(e){return e&&e.name&&e.version&&e.install}; /** * Returns `true` if a plugin
                                                                                            with the given `name` been installed on `module`. * @method isUsed * @param module {} The module. * @param name {string} The plugin name. * @return {boolean} `true`
                                                                                            if a plugin with the given `name` been installed on `module`, otherwise `false`. */i.isUsed=function(e,t){return e.used.indexOf(t)>-1}; /** * Returns `true` if `plugin.for` is applicable to `module` by comparing against `module.name` and `module.version`. * If `plugin.for` is not specified then
                                                                                            it is assumed to be applicable. * The value of `plugin.for` is a string of the format `'module-name'` or `'module-name@version'`. * @method isFor * @param plugin
                                                                                            {} The plugin. * @param module {} The module. * @return {boolean} `true` if `plugin.for` is applicable to `module`, otherwise `false`. */i.isFor=function(e,t){var
                                                                                            n=e.for&&i.dependencyParse(e.for);return!e.for||t.name===n.name&&i.versionSatisfies(t.version,n.range)}; /** * Installs the plugins by calling `plugin.install`
                                                                                            on each plugin specified in `plugins` if passed, otherwise `module.uses`. * For installing plugins on `Matter` see the convenience function `Matter.use`. * Plugins
                                                                                            may be specified either by their name or a reference to the plugin object. * Plugins themselves may specify further dependencies, but each plugin is installed
                                                                                            only once. * Order is important, a topological sort is performed to find the best resulting order of installation. * This sorting attempts to satisfy every dependency's
                                                                                            requested ordering, but may not be exact in all cases. * This function logs the resulting status of each dependency in the console, along with any warnings. *
                                                                                            - A green tick âœ… indicates a dependency was resolved and installed. * - An orange diamond ðŸ”¶ indicates a dependency was resolved but a warning was thrown for it
                                                                                            or one if its dependencies. * - A red cross âŒ indicates a dependency could not be resolved. * Avoid calling this function multiple times on the same module unless
                                                                                            you intend to manually control installation order. * @method use * @param module {} The module install plugins on. * @param [plugins=module.uses] {} The plugins
                                                                                            to install on module (optional, defaults to `module.uses`). */i.use=function(e,t){e.uses=(e.uses||[]).concat(t||[]);if(0!==e.uses.length){var n=i.dependencies(e),r=o.topologicalSort(n),a=[];for(var
                                                                                            s=0;s
                                                                                            <r.length;s+=1)if(r[s]!==e.name){var l=i.resolve(r[s]);if(l){if(!i.isUsed(e,l.name)){if(!i.isFor(l,e)){o.warn( "Plugin.use:",i.toString(l), "is for",l.for,
                                                                                                "but installed on",i.toString(e)+ ".");l._warned=true}if(l.install)l.install(e);else{o.warn( "Plugin.use:",i.toString(l), "does not specify an install function.");l._warned=true}if(l._warned){a.push(
                                                                                                "ðŸ”¶ "+i.toString(l));delete l._warned}else a.push( "âœ… "+i.toString(l));e.used.push(l.name)}}else a.push( "âŒ "+r[s])}a.length>0&&o.info(a.join(" "))}else o.warn("Plugin.use:",i.toString(e),"does not specify any dependencies to install.")}; /** * Recursively finds all of a module's dependencies
                                                                                                and returns a flat dependency graph. * @method dependencies * @param module {} The module. * @return {object} A dependency graph. */i.dependencies=function(e,t){var
                                                                                                n=i.dependencyParse(e),r=n.name;t=t||{};if(!(r in t)){e=i.resolve(e)||e;t[r]=o.map(e.uses||[],(function(t){i.isPlugin(t)&&i.register(t);var r=i.dependencyParse(t),a=i.resolve(t);if(a&&!i.versionSatisfies(a.version,r.range)){o.warn("Plugin.dependencies:",i.toString(a),"does
                                                                                                not satisfy",i.toString(r),"used by",i.toString(n)+".");a._warned=true;e._warned=true}else if(!a){o.warn("Plugin.dependencies:",i.toString(t),"used by",i.toString(n),"could
                                                                                                not be resolved.");e._warned=true}return r.name}));for(var a=0;a
                                                                                                <t[r].length;a+=1)i.dependencies(t[r][a],t);return t}}; /** * Parses a dependency string into
                                                                                                    its components. * The `dependency` is a string of the format ` 'module-name'` or ` 'module-name@version'`. * See documentation for `Plugin.versionParse` for
                                                                                                    a description of the format. * This function can also handle dependencies that are already resolved (e.g. a module object). * @method dependencyParse * @param
                                                                                                    dependency {string} The dependency of the format ` 'module-name'` or ` 'module-name@version'`. * @return {object} The dependency parsed into its components.
                                                                                                    */i.dependencyParse=function(e){if(o.isString(e)){var t=/^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-+]+)?))?$/;t.test(e)||o.warn(
                                                                                                    "Plugin.dependencyParse:",e, "is not a valid dependency string.");return{name:e.split( "@")[0],range:e.split( "@")[1]|| "*"}}return{name:e.name,range:e.range||e.version}}; /** * Parses
                                                                                                    a version string into its components. * Versions are strictly of the format `x.y.z` (as in [semver](http://semver.org/)). * Versions may optionally have a
                                                                                                    prerelease tag in the format `x.y.z-alpha`. * Ranges are a strict subset of [npm ranges](https://docs.npmjs.com/misc/semver#advanced-range-syntax). * Only
                                                                                                    the following range types are supported: * - Tilde ranges e.g. `~1.2.3` * - Caret ranges e.g. `^1.2.3` * - Greater than ranges e.g. `>1.2.3` * - Greater than or equal ranges e.g. `>=1.2.3` * - Exact version e.g. `1.2.3` * - Any version `*` * @method versionParse * @param range {string} The
                                                                                                    version string. * @return {object} The version range parsed into its components. */i.versionParse=function(e){var t=/^(\*)|(\^|~|>=|>)?\s*((\d+)\.(\d+)\.(\d+))(-[0-9A-Za-z-+]+)?$/;t.test(e)||o.warn("Plugin.versionParse:",e,"is
                                                                                                    not a valid version or range.");var n=t.exec(e);var i=Number(n[4]);var r=Number(n[5]);var a=Number(n[6]);return{isRange:Boolean(n[1]||n[2]),version:n[3],range:e,operator:n[1]||n[2]||"",major:i,minor:r,patch:a,parts:[i,r,a],prerelease:n[7],number:1e8*i+1e4*r+a}};
                                                                                                    /** * Returns `true` if `version` satisfies the given `range`. * See documentation for `Plugin.versionParse` for a description of the format. * If a version
                                                                                                    or range is not specified, then any version (`*`) is assumed to satisfy. * @method versionSatisfies * @param version {string} The version string. * @param
                                                                                                    range {string} The range string. * @return {boolean} `true` if `version` satisfies `range`, otherwise `false`. */i.versionSatisfies=function(e,t){t=t||"*";var
                                                                                                    n=i.versionParse(t),o=i.versionParse(e);if(n.isRange){if("*"===n.operator||"*"===e)return true;if(">"===n.operator)return o.number>n.number;if(">="===n.operator)return
                                                                                                    o.number>=n.number;if("~"===n.operator)return o.major===n.major&&o.minor===n.minor&&o.patch>=n.patch;if("^"===n.operator)return n.major>0?o.major===n.major&&o.number>=n.number:n.minor>0?o.minor===n.minor&&o.patch>=n.patch:o.patch===n.patch}return
                                                                                                    e===t||"*"===e}})()},function(e,t,n){var i={};e.exports=i;var o=n(0);var r=n(5);var a=n(1);var s=n(4);var l=n(2);var c=n(13);(function(){var e,t;if("undefined"!==typeof
                                                                                                    window){e=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.msRequestAnimationFrame||function(e){window.setTimeout((function(){e(o.now())}),1e3/60)};t=window.cancelAnimationFrame||window.mozCancelAnimationFrame||window.webkitCancelAnimationFrame||window.msCancelAnimationFrame}i._goodFps=30;i._goodDelta=1e3/60;
                                                                                                    /** * Creates a new renderer. The options parameter is an object that specifies any properties you wish to override the defaults. * All properties have
                                                                                                    default values, and many are pre-calculated automatically based on other properties. * See the properties section below for detailed information on what
                                                                                                    you can pass via the `options` object. * @method create * @param {object} [options] * @return {render} A new renderer */i.create=function(e){var t={controller:i,engine:null,element:null,canvas:null,mouse:null,frameRequestId:null,timing:{historySize:60,delta:0,deltaHistory:[],lastTime:0,lastTimestamp:0,lastElapsed:0,timestampElapsed:0,timestampElapsedHistory:[],engineDeltaHistory:[],engineElapsedHistory:[],elapsedHistory:[]},options:{width:800,height:600,pixelRatio:1,background:"#14151f",wireframeBackground:"#14151f",hasBounds:!!e.bounds,enabled:true,wireframes:true,showSleeping:true,showDebug:false,showStats:false,showPerformance:false,showBounds:false,showVelocity:false,showCollisions:false,showSeparations:false,showAxes:false,showPositions:false,showAngleIndicator:false,showIds:false,showVertexNumbers:false,showConvexHulls:false,showInternalEdges:false,showMousePosition:false}};var
                                                                                                    n=o.extend(t,e);if(n.canvas){n.canvas.width=n.options.width||n.canvas.width;n.canvas.height=n.options.height||n.canvas.height}n.mouse=e.mouse;n.engine=e.engine;n.canvas=n.canvas||_createCanvas(n.options.width,n.options.height);n.context=n.canvas.getContext("2d");n.textures={};n.bounds=n.bounds||{min:{x:0,y:0},max:{x:n.canvas.width,y:n.canvas.height}};n.options.showBroadphase=false;1!==n.options.pixelRatio&&i.setPixelRatio(n,n.options.pixelRatio);o.isElement(n.element)?n.element.appendChild(n.canvas):n.canvas.parentNode||o.log("Render.create:
                                                                                                    options.element was undefined, render.canvas was created but not appended","warn");return n}; /** * Continuously updates the render canvas on the `requestAnimationFrame`
                                                                                                    event. * @method run * @param {render} render */i.run=function(t){(function loop(n){t.frameRequestId=e(loop);_updateTiming(t,n);i.world(t,n);(t.options.showStats||t.options.showDebug)&&i.stats(t,t.context,n);(t.options.showPerformance||t.options.showDebug)&&i.performance(t,t.context,n)})()};
                                                                                                    /** * Ends execution of `Render.run` on the given `render`, by canceling the animation frame request event loop. * @method stop * @param {render} render
                                                                                                    */i.stop=function(e){t(e.frameRequestId)}; /** * Sets the pixel ratio of the renderer and updates the canvas. * To automatically detect the correct ratio,
                                                                                                    pass the string `'auto'` for `pixelRatio`. * @method setPixelRatio * @param {render} render * @param {number} pixelRatio */i.setPixelRatio=function(e,t){var
                                                                                                    n=e.options,i=e.canvas;"auto"===t&&(t=_getPixelRatio(i));n.pixelRatio=t;i.setAttribute("data-pixel-ratio",t);i.width=n.width*t;i.height=n.height*t;i.style.width=n.width+"px";i.style.height=n.height+"px"};
                                                                                                    /** * Positions and sizes the viewport around the given object bounds. * Objects must have at least one of the following properties: * - `object.bounds`
                                                                                                    * - `object.position` * - `object.min` and `object.max` * - `object.x` and `object.y` * @method lookAt * @param {render} render * @param {object[]} objects
                                                                                                    * @param {vector} [padding] * @param {bool} [center=true] */i.lookAt=function(e,t,n,i){i="undefined"===typeof i||i;t=o.isArray(t)?t:[t];n=n||{x:0,y:0};var
                                                                                                    r={min:{x:Infinity,y:Infinity},max:{x:-Infinity,y:-Infinity}};for(var a=0;a
                                                                                                    <t.length;a+=1){var s=t[a],l=s.bounds?s.bounds.min:s.min||s.position||s,u=s.bounds?s.bounds.max:s.max||s.position||s;if(l&&u){l.x<r.min.x&&(r.min.x=l.x);u.x>r.max.x&&(r.max.x=u.x);l.y
                                                                                                        <r.min.y&&(r.min.y=l.y);u.y>r.max.y&&(r.max.y=u.y)}}var f=r.max.x-r.min.x+2*n.x,d=r.max.y-r.min.y+2*n.y,p=e.canvas.height,v=e.canvas.width,y=v/p,m=f/d,g=1,x=1;m>y?x=m/y:g=y/m;e.options.hasBounds=true;e.bounds.min.x=r.min.x;e.bounds.max.x=r.min.x+f*g;e.bounds.min.y=r.min.y;e.bounds.max.y=r.min.y+d*x;if(i){e.bounds.min.x+=.5*f-f*g*.5;e.bounds.max.x+=.5*f-f*g*.5;e.bounds.min.y+=.5*d-d*x*.5;e.bounds.max.y+=.5*d-d*x*.5}e.bounds.min.x-=n.x;e.bounds.max.x-=n.x;e.bounds.min.y-=n.y;e.bounds.max.y-=n.y;if(e.mouse){c.setScale(e.mouse,{x:(e.bounds.max.x-e.bounds.min.x)/e.canvas.width,y:(e.bounds.max.y-e.bounds.min.y)/e.canvas.height});c.setOffset(e.mouse,e.bounds.min)}};
                                                                                                            /** * Applies viewport transforms based on `render.bounds` to a render context. * @method startViewTransform * @param {render} render */i.startViewTransform=function(e){var
                                                                                                            t=e.bounds.max.x-e.bounds.min.x,n=e.bounds.max.y-e.bounds.min.y,i=t/e.options.width,o=n/e.options.height;e.context.setTransform(e.options.pixelRatio/i,0,0,e.options.pixelRatio/o,0,0);e.context.translate(-e.bounds.min.x,-e.bounds.min.y)};
                                                                                                            /** * Resets all transforms on the render context. * @method endViewTransform * @param {render} render */i.endViewTransform=function(e){e.context.setTransform(e.options.pixelRatio,0,0,e.options.pixelRatio,0,0)};
                                                                                                            /** * Renders the given `engine`'s `Matter.World` object. * This is the entry point for all rendering and should be called every time the scene
                                                                                                            changes. * @method world * @param {render} render */i.world=function(e,t){var n=o.now(),u=e.engine,f=u.world,d=e.canvas,p=e.context,v=e.options,y=e.timing;var
                                                                                                            m,g=r.allBodies(f),x=r.allConstraints(f),h=v.wireframes?v.wireframeBackground:v.background,b=[],S=[];var w={timestamp:u.timing.timestamp};s.trigger(e,"beforeRender",w);e.currentBackground!==h&&_applyBackground(e,h);p.globalCompositeOperation="source-in";p.fillStyle="transparent";p.fillRect(0,0,d.width,d.height);p.globalCompositeOperation="source-over";if(v.hasBounds){for(m=0;m
                                                                                                            <g.length;m++){var
                                                                                                                _=g[m];a.overlaps(_.bounds,e.bounds)&&b.push(_)}for(m=0;m<x.length;m++){var A=x[m],P=A.bodyA,C=A.bodyB,k=A.pointA,M=A.pointB;P&&(k=l.add(P.position,A.pointA));C&&(M=l.add(C.position,A.pointB));k&&M&&((a.contains(e.bounds,k)||a.contains(e.bounds,M))&&S.push(A))}i.startViewTransform(e);if(e.mouse){c.setScale(e.mouse,{x:(e.bounds.max.x-e.bounds.min.x)/e.options.width,y:(e.bounds.max.y-e.bounds.min.y)/e.options.height});c.setOffset(e.mouse,e.bounds.min)}}else{S=x;b=g;1!==e.options.pixelRatio&&e.context.setTransform(e.options.pixelRatio,0,0,e.options.pixelRatio,0,0)}if(!v.wireframes||u.enableSleeping&&v.showSleeping)i.bodies(e,b,p);else{v.showConvexHulls&&i.bodyConvexHulls(e,b,p);i.bodyWireframes(e,b,p)}v.showBounds&&i.bodyBounds(e,b,p);(v.showAxes||v.showAngleIndicator)&&i.bodyAxes(e,b,p);v.showPositions&&i.bodyPositions(e,b,p);v.showVelocity&&i.bodyVelocity(e,b,p);v.showIds&&i.bodyIds(e,b,p);v.showSeparations&&i.separations(e,u.pairs.list,p);v.showCollisions&&i.collisions(e,u.pairs.list,p);v.showVertexNumbers&&i.vertexNumbers(e,b,p);v.showMousePosition&&i.mousePosition(e,e.mouse,p);i.constraints(S,p);v.hasBounds&&i.endViewTransform(e);s.trigger(e,
                                                                                                                "afterRender",w);y.lastElapsed=o.now()-n}; /** * Renders statistics about the engine and world useful for debugging. * @private * @method stats * @param {render}
                                                                                                                render * @param {RenderingContext} context * @param {Number} time */i.stats=function(e,t,n){var i=e.engine,o=i.world,a=r.allBodies(o),s=0,l=55,c=44,u=0,f=0;for(var
                                                                                                                d=0;d<a.length;d+=1)s+=a[d].parts.length;var p={Part:s,Body:a.length,Cons:r.allConstraints(o).length,Comp:r.allComposites(o).length,Pair:i.pairs.list.length};t.fillStyle="#0e0f19"
                                                                                                                ;t.fillRect(u,f,5.5*l,c);t.font="12px Arial" ;t.textBaseline="top" ;t.textAlign="right" ;for(var v in p){var y=p[v];t.fillStyle="#aaa" ;t.fillText(v,u+l,f+8);t.fillStyle="#eee"
                                                                                                                ;t.fillText(y,u+l,f+26);u+=l}}; /** * Renders engine and render performance information. * @private * @method performance * @param {render} render
                                                                                                                * @param {RenderingContext} context */i.performance=function(e,t){var n=e.engine,o=e.timing,r=o.deltaHistory,a=o.elapsedHistory,s=o.timestampElapsedHistory,l=o.engineDeltaHistory,c=o.engineElapsedHistory,u=n.timing.lastDelta;var
                                                                                                                f=_mean(r),d=_mean(a),p=_mean(l),v=_mean(c),y=_mean(s),m=y/f||0,g=1e3/f||0;var x=4,h=12,b=60,S=34,w=10,_=69;t.fillStyle="#0e0f19" ;t.fillRect(0,50,4*h+5*b+22,S);i.status(t,w,_,b,x,r.length,Math.round(g)+
                                                                                                                " fps",g/i._goodFps,(function(e){return r[e]/f-1}));i.status(t,w+h+b,_,b,x,l.length,u.toFixed(2)+ " dt",i._goodDelta/u,(function(e){return l[e]/p-1}));i.status(t,w+2*(h+b),_,b,x,c.length,v.toFixed(2)+
                                                                                                                " ut",1-v/i._goodFps,(function(e){return c[e]/v-1}));i.status(t,w+3*(h+b),_,b,x,a.length,d.toFixed(2)+ " rt",1-d/i._goodFps,(function(e){return a[e]/d-1}));i.status(t,w+4*(h+b),_,b,x,s.length,m.toFixed(2)+
                                                                                                                " x",m*m*m,(function(e){return(s[e]/r[e]/m||0)-1}))}; /** * Renders a label, indicator and a chart. * @private * @method status * @param {RenderingContext}
                                                                                                                context * @param {number} x * @param {number} y * @param {number} width * @param {number} height * @param {number} count * @param {string} label
                                                                                                                * @param {string} indicator * @param {function} plotY */i.status=function(e,t,n,i,r,a,s,l,c){e.strokeStyle="#888" ;e.fillStyle="#444" ;e.lineWidth=1;e.fillRect(t,n+7,i,1);e.beginPath();e.moveTo(t,n+7-r*o.clamp(.4*c(0),-2,2));for(var
                                                                                                                u=0;u<i;u+=1)e.lineTo(t+u,n+7-(u<a?r*o.clamp(.4*c(u),-2,2):0));e.stroke();e.fillStyle="hsl(" +o.clamp(25+95*l,0,120)+ ",100%,60%)";e.fillRect(t,n-7,4,4);e.font="12px Arial"
                                                                                                                ;e.textBaseline="middle" ;e.textAlign="right" ;e.fillStyle="#eee" ;e.fillText(s,t+i,n-5)}; /** * Description * @private * @method constraints *
                                                                                                                @param {constraint[]} constraints * @param {RenderingContext} context */i.constraints=function(e,t){var n=t;for(var i=0;i<e.length;i++){var r=e[i];if(r.render.visible&&r.pointA&&r.pointB){var
                                                                                                                a,s,c=r.bodyA,u=r.bodyB;a=c?l.add(c.position,r.pointA):r.pointA;if( "pin"===r.render.type){n.beginPath();n.arc(a.x,a.y,3,0,2*Math.PI);n.closePath()}else{s=u?l.add(u.position,r.pointB):r.pointB;n.beginPath();n.moveTo(a.x,a.y);if(
                                                                                                                "spring"===r.render.type){var f,d=l.sub(s,a),p=l.perp(l.normalise(d)),v=Math.ceil(o.clamp(r.length/5,12,20));for(var y=1;y<v;y+=1){f=y%2===0?1:-1;n.lineTo(a.x+d.x*(y/v)+p.x*f*4,a.y+d.y*(y/v)+p.y*f*4)}}n.lineTo(s.x,s.y)}if(r.render.lineWidth){n.lineWidth=r.render.lineWidth;n.strokeStyle=r.render.strokeStyle;n.stroke()}if(r.render.anchors){n.fillStyle=r.render.strokeStyle;n.beginPath();n.arc(a.x,a.y,3,0,2*Math.PI);n.arc(s.x,s.y,3,0,2*Math.PI);n.closePath();n.fill()}}}};
                                                                                                            /** * Description * @private * @method bodies * @param {render} render * @param {body[]} bodies * @param {RenderingContext} context */i.bodies=function(e,t,n){var
                                                                                                                i,o,r,a,s=n,l=(e.engine,e.options),c=l.showInternalEdges||!l.wireframes;for(r=0;r<t.length;r++){i=t[r];if(i.render.visible)for(a=i.parts.length>1?1:0;a
                                                                                                                <i.parts.length;a++){o=i.parts[a];if(o.render.visible){l.showSleeping&&i.isSleeping?s.globalAlpha=.5*o.render.opacity:1!==o.render.opacity&&(s.globalAlpha=o.render.opacity);if(o.render.sprite&&o.render.sprite.texture&&!l.wireframes){var
                                                                                                                    u=o.render.sprite,f=_getTexture(e,u.texture);s.translate(o.position.x,o.position.y);s.rotate(o.angle);s.drawImage(f,f.width*-u.xOffset*u.xScale,f.height*-u.yOffset*u.yScale,f.width*u.xScale,f.height*u.yScale);s.rotate(-o.angle);s.translate(-o.position.x,-o.position.y)}else{if(o.circleRadius){s.beginPath();s.arc(o.position.x,o.position.y,o.circleRadius,0,2*Math.PI)}else{s.beginPath();s.moveTo(o.vertices[0].x,o.vertices[0].y);for(var
                                                                                                                    d=1;d<o.vertices.length;d++){!o.vertices[d-1].isInternal||c?s.lineTo(o.vertices[d].x,o.vertices[d].y):s.moveTo(o.vertices[d].x,o.vertices[d].y);o.vertices[d].isInternal&&!c&&s.moveTo(o.vertices[(d+1)%o.vertices.length].x,o.vertices[(d+1)%o.vertices.length].y)}s.lineTo(o.vertices[0].x,o.vertices[0].y);s.closePath()}if(l.wireframes){s.lineWidth=1;s.strokeStyle="#bbb"
                                                                                                                    ;s.stroke()}else{s.fillStyle=o.render.fillStyle;if(o.render.lineWidth){s.lineWidth=o.render.lineWidth;s.strokeStyle=o.render.strokeStyle;s.stroke()}s.fill()}}s.globalAlpha=1}}}};
                                                                                                                /** * Optimised method for drawing body wireframes in one pass * @private * @method bodyWireframes * @param {render} render * @param {body[]}
                                                                                                                    bodies * @param {RenderingContext} context */i.bodyWireframes=function(e,t,n){var i,o,r,a,s,l=n,c=e.options.showInternalEdges;l.beginPath();for(r=0;r<t.length;r++){i=t[r];if(i.render.visible)for(s=i.parts.length>1?1:0;s
                                                                                                                    <i.parts.length;s++){o=i.parts[s];l.moveTo(o.vertices[0].x,o.vertices[0].y);for(a=1;a<o.vertices.length;a++){!o.vertices[a-1].isInternal||c?l.lineTo(o.vertices[a].x,o.vertices[a].y):l.moveTo(o.vertices[a].x,o.vertices[a].y);o.vertices[a].isInternal&&!c&&l.moveTo(o.vertices[(a+1)%o.vertices.length].x,o.vertices[(a+1)%o.vertices.length].y)}l.lineTo(o.vertices[0].x,o.vertices[0].y)}}l.lineWidth=1;l.strokeStyle="#bbb"
                                                                                                                        ;l.stroke()}; /** * Optimised method for drawing body convex hull wireframes in one pass * @private * @method bodyConvexHulls * @param
                                                                                                                        {render} render * @param {body[]} bodies * @param {RenderingContext} context */i.bodyConvexHulls=function(e,t,n){var i,o,r,a=n;a.beginPath();for(o=0;o<t.length;o++){i=t[o];if(i.render.visible&&1!==i.parts.length){a.moveTo(i.vertices[0].x,i.vertices[0].y);for(r=1;r<i.vertices.length;r++)a.lineTo(i.vertices[r].x,i.vertices[r].y);a.lineTo(i.vertices[0].x,i.vertices[0].y)}}a.lineWidth=1;a.strokeStyle="rgba(255,255,255,0.2)"
                                                                                                                        ;a.stroke()}; /** * Renders body vertex numbers. * @private * @method vertexNumbers * @param {render} render * @param {body[]} bodies *
                                                                                                                        @param {RenderingContext} context */i.vertexNumbers=function(e,t,n){var i,o,r,a=n;for(i=0;i<t.length;i++){var s=t[i].parts;for(r=s.length>1?1:0;r
                                                                                                                        <s.length;r++){var l=s[r];for(o=0;o<l.vertices.length;o++){a.fillStyle="rgba(255,255,255,0.2)" ;a.fillText(i+ "_"+o,l.position.x+.8*(l.vertices[o].x-l.position.x),l.position.y+.8*(l.vertices[o].y-l.position.y))}}}};
                                                                                                                        /** * Renders mouse position. * @private * @method mousePosition * @param {render} render * @param {mouse} mouse * @param {RenderingContext}
                                                                                                                            context */i.mousePosition=function(e,t,n){var i=n;i.fillStyle="rgba(255,255,255,0.8)" ;i.fillText(t.position.x+ "  "+t.position.y,t.position.x+5,t.position.y-5)};
                                                                                                                        /** * Draws body bounds * @private * @method bodyBounds * @param {render} render * @param {body[]} bodies * @param {RenderingContext}
                                                                                                                            context */i.bodyBounds=function(e,t,n){var i=n,o=(e.engine,e.options);i.beginPath();for(var r=0;r<t.length;r++){var a=t[r];if(a.render.visible){var
                                                                                                                            s=t[r].parts;for(var l=s.length>1?1:0;l
                                                                                                                            <s.length;l++){var c=s[l];i.rect(c.bounds.min.x,c.bounds.min.y,c.bounds.max.x-c.bounds.min.x,c.bounds.max.y-c.bounds.min.y)}}}o.wireframes?i.strokeStyle="rgba(255,255,255,0.08)"
                                                                                                                                :i.strokeStyle="rgba(0,0,0,0.1)" ;i.lineWidth=1;i.stroke()}; /** * Draws body angle indicators and axes * @private * @method bodyAxes
                                                                                                                                * @param {render} render * @param {body[]} bodies * @param {RenderingContext} context */i.bodyAxes=function(e,t,n){var i,o,r,a,s=n,l=(e.engine,e.options);s.beginPath();for(o=0;o<t.length;o++){var
                                                                                                                                c=t[o],u=c.parts;if(c.render.visible)if(l.showAxes)for(r=u.length>1?1:0;r
                                                                                                                                <u.length;r++){i=u[r];for(a=0;a<i.axes.length;a++){var f=i.axes[a];s.moveTo(i.position.x,i.position.y);s.lineTo(i.position.x+20*f.x,i.position.y+20*f.y)}}else
                                                                                                                                    for(r=u.length>1?1:0;r
                                                                                                                                    <u.length;r++){i=u[r];for(a=0;a<i.axes.length;a++){s.moveTo(i.position.x,i.position.y);s.lineTo((i.vertices[0].x+i.vertices[i.vertices.length-1].x)/2,(i.vertices[0].y+i.vertices[i.vertices.length-1].y)/2)}}}if(l.wireframes){s.strokeStyle="indianred"
                                                                                                                                        ;s.lineWidth=1}else{s.strokeStyle="rgba(255, 255, 255, 0.4)" ;s.globalCompositeOperation="overlay" ;s.lineWidth=2}s.stroke();s.globalCompositeOperation="source-over"
                                                                                                                                        }; /** * Draws body positions * @private * @method bodyPositions * @param {render} render * @param {body[]} bodies * @param
                                                                                                                                        {RenderingContext} context */i.bodyPositions=function(e,t,n){var i,o,r,a,s=n,l=(e.engine,e.options);s.beginPath();for(r=0;r<t.length;r++){i=t[r];if(i.render.visible)for(a=0;a<i.parts.length;a++){o=i.parts[a];s.arc(o.position.x,o.position.y,3,0,2*Math.PI,false);s.closePath()}}l.wireframes?s.fillStyle="indianred"
                                                                                                                                        :s.fillStyle="rgba(0,0,0,0.5)" ;s.fill();s.beginPath();for(r=0;r<t.length;r++){i=t[r];if(i.render.visible){s.arc(i.positionPrev.x,i.positionPrev.y,2,0,2*Math.PI,false);s.closePath()}}s.fillStyle="rgba(255,165,0,0.8)"
                                                                                                                                        ;s.fill()}; /** * Draws body velocity * @private * @method bodyVelocity * @param {render} render * @param {body[]} bodies
                                                                                                                                        * @param {RenderingContext} context */i.bodyVelocity=function(e,t,n){var i=n;i.beginPath();for(var o=0;o<t.length;o++){var
                                                                                                                                        r=t[o];if(r.render.visible){i.moveTo(r.position.x,r.position.y);i.lineTo(r.position.x+2*(r.position.x-r.positionPrev.x),r.position.y+2*(r.position.y-r.positionPrev.y))}}i.lineWidth=3;i.strokeStyle="cornflowerblue"
                                                                                                                                        ;i.stroke()}; /** * Draws body ids * @private * @method bodyIds * @param {render} render * @param {body[]} bodies * @param
                                                                                                                                        {RenderingContext} context */i.bodyIds=function(e,t,n){var i,o,r=n;for(i=0;i<t.length;i++)if(t[i].render.visible){var a=t[i].parts;for(o=a.length>1?1:0;o
                                                                                                                                        <a.length;o++){var s=a[o];r.font="12px Arial" ;r.fillStyle="rgba(255,255,255,0.5)" ;r.fillText(s.id,s.position.x+10,s.position.y-10)}}};
                                                                                                                                        /** * Description * @private * @method collisions * @param {render} render * @param {pair[]} pairs * @param {RenderingContext}
                                                                                                                                            context */i.collisions=function(e,t,n){var i,o,r,a,s=n,l=e.options;s.beginPath();for(r=0;r<t.length;r++){i=t[r];if(i.isActive){o=i.collision;for(a=0;a<i.activeContacts.length;a++){var
                                                                                                                                            c=i.activeContacts[a],u=c.vertex;s.rect(u.x-1.5,u.y-1.5,3.5,3.5)}}}l.wireframes?s.fillStyle="rgba(255,255,255,0.7)"
                                                                                                                                            :s.fillStyle="orange" ;s.fill();s.beginPath();for(r=0;r<t.length;r++){i=t[r];if(i.isActive){o=i.collision;if(i.activeContacts.length>0){var f=i.activeContacts[0].vertex.x,d=i.activeContacts[0].vertex.y;if(2===i.activeContacts.length){f=(i.activeContacts[0].vertex.x+i.activeContacts[1].vertex.x)/2;d=(i.activeContacts[0].vertex.y+i.activeContacts[1].vertex.y)/2}o.bodyB===o.supports[0].body||true===o.bodyA.isStatic?s.moveTo(f-8*o.normal.x,d-8*o.normal.y):s.moveTo(f+8*o.normal.x,d+8*o.normal.y);s.lineTo(f,d)}}}l.wireframes?s.strokeStyle="rgba(255,165,0,0.7)":s.strokeStyle="orange";s.lineWidth=1;s.stroke()};
                                                                                                                                            /** * Description * @private * @method separations * @param {render} render * @param {pair[]} pairs * @param {RenderingContext}
                                                                                                                                            context */i.separations=function(e,t,n){var i,o,r,a,s,l=n,c=e.options;l.beginPath();for(s=0;s
                                                                                                                                            <t.length;s++){i=t[s];if(i.isActive){o=i.collision;r=o.bodyA;a=o.bodyB;var
                                                                                                                                                u=1;a.isStatic||r.isStatic||(u=.5);a.isStatic&&(u=0);l.moveTo(a.position.x,a.position.y);l.lineTo(a.position.x-o.penetration.x*u,a.position.y-o.penetration.y*u);u=1;a.isStatic||r.isStatic||(u=.5);r.isStatic&&(u=0);l.moveTo(r.position.x,r.position.y);l.lineTo(r.position.x+o.penetration.x*u,r.position.y+o.penetration.y*u)}}c.wireframes?l.strokeStyle="rgba(255,165,0,0.5)"
                                                                                                                                                :l.strokeStyle="orange" ;l.stroke()}; /** * Description * @private * @method inspector * @param {inspector} inspector
                                                                                                                                                * @param {RenderingContext} context */i.inspector=function(e,t){e.engine;var n,i=e.selected,o=e.render,r=o.options;if(r.hasBounds){var
                                                                                                                                                a=o.bounds.max.x-o.bounds.min.x,s=o.bounds.max.y-o.bounds.min.y,l=a/o.options.width,c=s/o.options.height;t.scale(1/l,1/c);t.translate(-o.bounds.min.x,-o.bounds.min.y)}for(var
                                                                                                                                                u=0;u<i.length;u++){var f=i[u].data;t.translate(.5,.5);t.lineWidth=1;t.strokeStyle="rgba(255,165,0,0.9)" ;t.setLineDash([1,2]);switch(f.type){case
                                                                                                                                                "body":n=f.bounds;t.beginPath();t.rect(Math.floor(n.min.x-3),Math.floor(n.min.y-3),Math.floor(n.max.x-n.min.x+6),Math.floor(n.max.y-n.min.y+6));t.closePath();t.stroke();break;case
                                                                                                                                                "constraint":var d=f.pointA;f.bodyA&&(d=f.pointB);t.beginPath();t.arc(d.x,d.y,10,0,2*Math.PI);t.closePath();t.stroke();break}t.setLineDash([]);t.translate(-.5,-.5)}if(null!==e.selectStart){t.translate(.5,.5);t.lineWidth=1;t.strokeStyle="rgba(255,165,0,0.6)"
                                                                                                                                                ;t.fillStyle="rgba(255,165,0,0.1)" ;n=e.selectBounds;t.beginPath();t.rect(Math.floor(n.min.x),Math.floor(n.min.y),Math.floor(n.max.x-n.min.x),Math.floor(n.max.y-n.min.y));t.closePath();t.stroke();t.fill();t.translate(-.5,-.5)}r.hasBounds&&t.setTransform(1,0,0,1,0,0)};
                                                                                                                                            /** * Updates render timing. * @method _updateTiming * @private * @param {render} render * @param {number} time
                                                                                                                                                */var _updateTiming=function(e,t){var n=e.engine,o=e.timing,r=o.historySize,a=n.timing.timestamp;o.delta=t-o.lastTime||i._goodDelta;o.lastTime=t;o.timestampElapsed=a-o.lastTimestamp||0;o.lastTimestamp=a;o.deltaHistory.unshift(o.delta);o.deltaHistory.length=Math.min(o.deltaHistory.length,r);o.engineDeltaHistory.unshift(n.timing.lastDelta);o.engineDeltaHistory.length=Math.min(o.engineDeltaHistory.length,r);o.timestampElapsedHistory.unshift(o.timestampElapsed);o.timestampElapsedHistory.length=Math.min(o.timestampElapsedHistory.length,r);o.engineElapsedHistory.unshift(n.timing.lastElapsed);o.engineElapsedHistory.length=Math.min(o.engineElapsedHistory.length,r);o.elapsedHistory.unshift(o.lastElapsed);o.elapsedHistory.length=Math.min(o.elapsedHistory.length,r)};
                                                                                                                                            /** * Returns the mean value of the given numbers. * @method _mean * @private * @param {Number[]} values * @return
                                                                                                                                                {Number} the mean of given values */var _mean=function(e){var t=0;for(var n=0;n<e.length;n+=1)t+=e[n];return t/e.length||0};
                                                                                                                                            /** * @method _createCanvas * @private * @param {} width * @param {} height * @return canvas */var _createCanvas=function(e,t){var
                                                                                                                                                n=document.createElement( "canvas");n.width=e;n.height=t;n.oncontextmenu=function(){return false};n.onselectstart=function(){return
                                                                                                                                                false};return n}; /** * Gets the pixel ratio of the canvas. * @method _getPixelRatio * @private * @param {HTMLElement}
                                                                                                                                                canvas * @return {Number} pixel ratio */var _getPixelRatio=function(e){var t=e.getContext( "2d"),n=window.devicePixelRatio||1,i=t.webkitBackingStorePixelRatio||t.mozBackingStorePixelRatio||t.msBackingStorePixelRatio||t.oBackingStorePixelRatio||t.backingStorePixelRatio||1;return
                                                                                                                                                n/i}; /** * Gets the requested texture (an Image) via its path * @method _getTexture * @private * @param {render}
                                                                                                                                                render * @param {string} imagePath * @return {Image} texture */var _getTexture=function(e,t){var n=e.textures[t];if(n)return
                                                                                                                                                n;n=e.textures[t]=new Image;n.src=t;return n}; /** * Applies the background to the canvas using CSS. * @method
                                                                                                                                                applyBackground * @private * @param {render} render * @param {string} background */var _applyBackground=function(e,t){var
                                                                                                                                                n=t;/(jpg|gif|png)$/.test(t)&&(n="url(" +t+ ")");e.canvas.style.background=n;e.canvas.style.backgroundSize="contain"
                                                                                                                                                ;e.currentBackground=t}; /** * Fired before rendering * * @event beforeRender * @param {} event An event object
                                                                                                                                                * @param {number} event.timestamp The engine.timing.timestamp of the event * @param {} event.source The source
                                                                                                                                                object of the event * @param {} event.name The name of the event */ /** * Fired after rendering * * @event afterRender
                                                                                                                                                * @param {} event An event object * @param {number} event.timestamp The engine.timing.timestamp of the event *
                                                                                                                                                @param {} event.source The source object of the event * @param {} event.name The name of the event */ /** * A back-reference
                                                                                                                                                to the `Matter.Render` module. * * @property controller * @type render */ /** * A reference to the `Matter.Engine`
                                                                                                                                                instance to be used. * * @property engine * @type engine */ /** * A reference to the element where the canvas is
                                                                                                                                                to be inserted (if `render.canvas` has not been specified) * * @property element * @type HTMLElement * @default
                                                                                                                                                null */ /** * The canvas element to render to. If not specified, one will be created if `render.element` has been
                                                                                                                                                specified. * * @property canvas * @type HTMLCanvasElement * @default null */ /** * A `Bounds` object that specifies
                                                                                                                                                the drawing view region. * Rendering will be automatically transformed and scaled to fit within the canvas size
                                                                                                                                                (`render.options.width` and `render.options.height`). * This allows for creating views that can pan or zoom around
                                                                                                                                                the scene. * You must also set `render.options.hasBounds` to `true` to enable bounded rendering. * * @property
                                                                                                                                                bounds * @type bounds */ /** * The 2d rendering context from the `render.canvas` element. * * @property context
                                                                                                                                                * @type CanvasRenderingContext2D */ /** * The sprite texture cache. * * @property textures * @type {} */ /** *
                                                                                                                                                The mouse to render if `render.options.showMousePosition` is enabled. * * @property mouse * @type mouse * @default
                                                                                                                                                null */ /** * The configuration options of the renderer. * * @property options * @type {} */ /** * The target width
                                                                                                                                                in pixels of the `render.canvas` to be created. * See also the `options.pixelRatio` property to change render quality.
                                                                                                                                                * * @property options.width * @type number * @default 800 */ /** * The target height in pixels of the `render.canvas`
                                                                                                                                                to be created. * See also the `options.pixelRatio` property to change render quality. * * @property options.height
                                                                                                                                                * @type number * @default 600 */ /** * The [pixel ratio](https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio)
                                                                                                                                                to use when rendering. * * @property options.pixelRatio * @type number * @default 1 */ /** * A CSS background color
                                                                                                                                                string to use when `render.options.wireframes` is disabled. * This may be also set to ` 'transparent'` or equivalent.
                                                                                                                                                * * @property options.background * @type string * @default '#14151f' */ /** * A CSS background color string to
                                                                                                                                                use when `render.options.wireframes` is enabled. * This may be also set to ` 'transparent'` or equivalent. * *
                                                                                                                                                @property options.wireframeBackground * @type string * @default '#14151f' */ /** * A flag that specifies if `render.bounds`
                                                                                                                                                should be used when rendering. * * @property options.hasBounds * @type boolean * @default false */ /** * A flag
                                                                                                                                                to enable or disable all debug information overlays together. * This includes and has priority over the values
                                                                                                                                                of: * * - `render.options.showStats` * - `render.options.showPerformance` * * @property options.showDebug * @type
                                                                                                                                                boolean * @default false */ /** * A flag to enable or disable the engine stats info overlay. * From left to right,
                                                                                                                                                the values shown are: * * - body parts total * - body total * - constraints total * - composites total * - collision
                                                                                                                                                pairs total * * @property options.showStats * @type boolean * @default false */ /** * A flag to enable or disable
                                                                                                                                                performance charts. * From left to right, the values shown are: * * - average render frequency (e.g. 60 fps) *
                                                                                                                                                - exact engine delta time used for last update (e.g. 16.66ms) * - average engine execution duration (e.g. 5.00ms)
                                                                                                                                                * - average render execution duration (e.g. 0.40ms) * - average effective play speed (e.g. '1.00x' is
                                                                                                                                                'real-time') * * Each value is recorded over a fixed sample of past frames (60 frames). * * A chart shown below each value
                                                                                                                                                indicates the variance from the average over the sample. * The more stable or fixed the value is the flatter the
                                                                                                                                                chart will appear. * * @property options.showPerformance * @type boolean * @default false */ /** * A flag to enable
                                                                                                                                                or disable rendering entirely. * * @property options.enabled * @type boolean * @default false */ /** * A flag to
                                                                                                                                                toggle wireframe rendering otherwise solid fill rendering is used. * * @property options.wireframes * @type boolean
                                                                                                                                                * @default true */ /** * A flag to enable or disable sleeping bodies indicators. * * @property options.showSleeping
                                                                                                                                                * @type boolean * @default true */ /** * A flag to enable or disable the debug information overlay. * * @property
                                                                                                                                                options.showDebug * @type boolean * @default false */ /** * A flag to enable or disable the collision broadphase
                                                                                                                                                debug overlay. * * @deprecated no longer implemented * @property options.showBroadphase * @type boolean * @default
                                                                                                                                                false */ /** * A flag to enable or disable the body bounds debug overlay. * * @property options.showBounds * @type
                                                                                                                                                boolean * @default false */ /** * A flag to enable or disable the body velocity debug overlay. * * @property options.showVelocity
                                                                                                                                                * @type boolean * @default false */ /** * A flag to enable or disable the body collisions debug overlay. * * @property
                                                                                                                                                options.showCollisions * @type boolean * @default false */ /** * A flag to enable or disable the collision resolver
                                                                                                                                                separations debug overlay. * * @property options.showSeparations * @type boolean * @default false */ /** * A flag
                                                                                                                                                to enable or disable the body axes debug overlay. * * @property options.showAxes * @type boolean * @default false
                                                                                                                                                */ /** * A flag to enable or disable the body positions debug overlay. * * @property options.showPositions * @type
                                                                                                                                                boolean * @default false */ /** * A flag to enable or disable the body angle debug overlay. * * @property options.showAngleIndicator
                                                                                                                                                * @type boolean * @default false */ /** * A flag to enable or disable the body and part ids debug overlay. * *
                                                                                                                                                @property options.showIds * @type boolean * @default false */ /** * A flag to enable or disable the body vertex
                                                                                                                                                numbers debug overlay. * * @property options.showVertexNumbers * @type boolean * @default false */ /** * A flag
                                                                                                                                                to enable or disable the body convex hulls debug overlay. * * @property options.showConvexHulls * @type boolean
                                                                                                                                                * @default false */ /** * A flag to enable or disable the body internal edges debug overlay. * * @property options.showInternalEdges
                                                                                                                                                * @type boolean * @default false */ /** * A flag to enable or disable the mouse position debug overlay. * * @property
                                                                                                                                                options.showMousePosition * @type boolean * @default false */})()},function(e,t){var n={};e.exports=n;(function(){
                                                                                                                                            /** * Creates a new contact. * @method create * @param {vertex} vertex * @return {contact} A new contact */ n.create=function(e){return{vertex:e,normalImpulse:0,tangentImpulse:0}}})()},function(e,t,n){var
                                                                                                                                                i={};e.exports=i;var o=n(7);var r=n(19);var a=n(14);var s=n(20);var l=n(4);var c=n(5);var u=n(10);var f=n(0);var
                                                                                                                                                d=n(6);(function(){ /** * Creates a new engine. The options parameter is an object that specifies any properties
                                                                                                                                                you wish to override the defaults. * All properties have default values, and many are pre-calculated automatically
                                                                                                                                                based on other properties. * See the properties section below for detailed information on what you can pass via
                                                                                                                                                the `options` object. * @method create * @param {object} [options] * @return {engine} engine */ i.create=function(e){e=e||{};var
                                                                                                                                                t={positionIterations:6,velocityIterations:4,constraintIterations:2,enableSleeping:false,events:[],plugin:{},gravity:{x:0,y:1,scale:.001},timing:{timestamp:0,timeScale:1,lastDelta:0,lastElapsed:0}};var
                                                                                                                                                n=f.extend(t,e);n.world=e.world||c.create({label: "World"});n.pairs=e.pairs||s.create();n.detector=e.detector||a.create();n.grid={buckets:[]};n.world.gravity=n.gravity;n.broadphase=n.grid;n.metrics={};return
                                                                                                                                                n}; /** * Moves the simulation forward in time by `delta` ms. * The `correction` argument is an optional `Number`
                                                                                                                                                that specifies the time correction factor to apply to the update. * This can help improve the accuracy of the simulation
                                                                                                                                                in cases where `delta` is changing between updates. * The value of `correction` is defined as `delta / lastDelta`,
                                                                                                                                                i.e. the percentage change of `delta` over the last step. * Therefore the value is always `1` (no correction) when
                                                                                                                                                `delta` constant (or when no correction is desired, which is the default). * See the paper on <a href="http://lonesock.net/article/verlet.html">Time Corrected Verlet</a> for more information. * * Triggers `beforeUpdate` and `afterUpdate` events. * Triggers
                                                                                                                                                `collisionStart`, `collisionActive` and `collisionEnd` events. * @method update * @param {engine} engine *
                                                                                                                                                @param {number} [delta=16.666] * @param {number} [correction=1] */i.update=function(e,t,n){var d=f.now();t=t||1e3/60;n=n||1;var
                                                                                                                                                p,v=e.world,y=e.detector,m=e.pairs,g=e.timing,x=g.timestamp;g.timestamp+=t*g.timeScale;g.lastDelta=t*g.timeScale;var
                                                                                                                                                h={timestamp:g.timestamp};l.trigger(e,"beforeUpdate",h);var b=c.allBodies(v),S=c.allConstraints(v);v.isModified&&a.setBodies(y,b);v.isModified&&c.setModified(v,false,false,true);e.enableSleeping&&o.update(b,g.timeScale);i._bodiesApplyGravity(b,e.gravity);i._bodiesUpdate(b,t,g.timeScale,n,v.bounds);u.preSolveAll(b);for(p=0;p
                                                                                                                                                <e.constraintIterations;p++)u.solveAll(S,g.timeScale);u.postSolveAll(b);y.pairs=e.pairs;var
                                                                                                                                                    w=a.collisions(y);s.update(m,w,x);e.enableSleeping&&o.afterCollisions(m.list,g.timeScale);m.collisionStart.length>0&&l.trigger(e,"collisionStart",{pairs:m.collisionStart});r.preSolvePosition(m.list);for(p=0;p
                                                                                                                                                    <e.positionIterations;p++)r.solvePosition(m.list,g.timeScale);r.postSolvePosition(b);u.preSolveAll(b);for(p=0;p<e.constraintIterations;p++)u.solveAll(S,g.timeScale);u.postSolveAll(b);r.preSolveVelocity(m.list);for(p=0;p<e.velocityIterations;p++)r.solveVelocity(m.list,g.timeScale);m.collisionActive.length>0&&l.trigger(e,"collisionActive",{pairs:m.collisionActive});m.collisionEnd.length>0&&l.trigger(e,"collisionEnd",{pairs:m.collisionEnd});i._bodiesClearForces(b);l.trigger(e,"afterUpdate",h);e.timing.lastElapsed=f.now()-d;return
                                                                                                                                                        e}; /** * Merges two engines by keeping the configuration of `engineA` but replacing the world with
                                                                                                                                                        the one from `engineB`. * @method merge * @param {engine} engineA * @param {engine} engineB */i.merge=function(e,t){f.extend(e,t);if(t.world){e.world=t.world;i.clear(e);var
                                                                                                                                                        n=c.allBodies(e.world);for(var r=0;r
                                                                                                                                                        <n.length;r++){var a=n[r];o.set(a,false);a.id=f.nextId()}}}; /**
                                                                                                                                                            * Clears the engine pairs and detector. * @method clear * @param {engine} engine */i.clear=function(e){s.clear(e.pairs);a.clear(e.detector)};
                                                                                                                                                        /** * Zeroes the `body.force` and `body.torque` force buffers. * @method _bodiesClearForces * @private
                                                                                                                                                            * @param {body[]} bodies */i._bodiesClearForces=function(e){for(var t=0;t<e.length;t++){var n=e[t];n.force.x=0;n.force.y=0;n.torque=0}};
                                                                                                                                                        /** * Applys a mass dependant force to all given bodies. * @method _bodiesApplyGravity * @private *
                                                                                                                                                            @param {body[]} bodies * @param {vector} gravity */i._bodiesApplyGravity=function(e,t){var n="undefined"
                                                                                                                                                            !==typeof t.scale?t.scale:.001;if((0!==t.x||0!==t.y)&&0!==n)for(var i=0;i<e.length;i++){var o=e[i];if(!o.isStatic&&!o.isSleeping){o.force.y+=o.mass*t.y*n;o.force.x+=o.mass*t.x*n}}};
                                                                                                                                                        /** * Applys `Body.update` to all given `bodies`. * @method _bodiesUpdate * @private * @param {body[]}
                                                                                                                                                            bodies * @param {number} deltaTime * The amount of time elapsed between updates * @param {number} timeScale
                                                                                                                                                            * @param {number} correction * The Verlet correction factor (deltaTime / lastDeltaTime) * @param {bounds}
                                                                                                                                                            worldBounds */i._bodiesUpdate=function(e,t,n,i,o){for(var r=0;r<e.length;r++){var a=e[r];a.isStatic||a.isSleeping||d.update(a,t,n,i)}};
                                                                                                                                                        /** * A deprecated alias for `Runner.run`, use `Matter.Runner.run(engine)` instead and see `Matter.Runner`
                                                                                                                                                            for more information. * @deprecated use Matter.Runner.run(engine) instead * @method run * @param {engine}
                                                                                                                                                            engine */ /** * Fired just before an update * * @event beforeUpdate * @param {object} event An event
                                                                                                                                                            object * @param {number} event.timestamp The engine.timing.timestamp of the event * @param {engine}
                                                                                                                                                            event.source The source object of the event * @param {string} event.name The name of the event */ /**
                                                                                                                                                            * Fired after engine update and all collision events * * @event afterUpdate * @param {object} event
                                                                                                                                                            An event object * @param {number} event.timestamp The engine.timing.timestamp of the event * @param
                                                                                                                                                            {engine} event.source The source object of the event * @param {string} event.name The name of the event
                                                                                                                                                            */ /** * Fired after engine update, provides a list of all pairs that have started to collide in the
                                                                                                                                                            current tick (if any) * * @event collisionStart * @param {object} event An event object * @param {pair[]}
                                                                                                                                                            event.pairs List of affected pairs * @param {number} event.timestamp The engine.timing.timestamp of
                                                                                                                                                            the event * @param {engine} event.source The source object of the event * @param {string} event.name
                                                                                                                                                            The name of the event */ /** * Fired after engine update, provides a list of all pairs that are colliding
                                                                                                                                                            in the current tick (if any) * * @event collisionActive * @param {object} event An event object * @param
                                                                                                                                                            {pair[]} event.pairs List of affected pairs * @param {number} event.timestamp The engine.timing.timestamp
                                                                                                                                                            of the event * @param {engine} event.source The source object of the event * @param {string} event.name
                                                                                                                                                            The name of the event */ /** * Fired after engine update, provides a list of all pairs that have ended
                                                                                                                                                            collision in the current tick (if any) * * @event collisionEnd * @param {object} event An event object
                                                                                                                                                            * @param {pair[]} event.pairs List of affected pairs * @param {number} event.timestamp The engine.timing.timestamp
                                                                                                                                                            of the event * @param {engine} event.source The source object of the event * @param {string} event.name
                                                                                                                                                            The name of the event */ /** * An integer `Number` that specifies the number of position iterations
                                                                                                                                                            to perform each update. * The higher the value, the higher quality the simulation will be at the expense
                                                                                                                                                            of performance. * * @property positionIterations * @type number * @default 6 */ /** * An integer `Number`
                                                                                                                                                            that specifies the number of velocity iterations to perform each update. * The higher the value, the
                                                                                                                                                            higher quality the simulation will be at the expense of performance. * * @property velocityIterations
                                                                                                                                                            * @type number * @default 4 */ /** * An integer `Number` that specifies the number of constraint iterations
                                                                                                                                                            to perform each update. * The higher the value, the higher quality the simulation will be at the expense
                                                                                                                                                            of performance. * The default value of `2` is usually very adequate. * * @property constraintIterations
                                                                                                                                                            * @type number * @default 2 */ /** * A flag that specifies whether the engine should allow sleeping
                                                                                                                                                            via the `Matter.Sleeping` module. * Sleeping can improve stability and performance, but often at the
                                                                                                                                                            expense of accuracy. * * @property enableSleeping * @type boolean * @default false */ /** * An `Object`
                                                                                                                                                            containing properties regarding the timing systems of the engine. * * @property timing * @type object
                                                                                                                                                            */ /** * A `Number` that specifies the global scaling factor of time for all bodies. * A value of `0`
                                                                                                                                                            freezes the simulation. * A value of `0.1` gives a slow-motion effect. * A value of `1.2` gives a speed-up
                                                                                                                                                            effect. * * @property timing.timeScale * @type number * @default 1 */ /** * A `Number` that specifies
                                                                                                                                                            the current simulation-time in milliseconds starting from `0`. * It is incremented on every `Engine.update`
                                                                                                                                                            by the given `delta` argument. * * @property timing.timestamp * @type number * @default 0 */ /** *
                                                                                                                                                            A `Number` that represents the total execution time elapsed during the last `Engine.update` in milliseconds.
                                                                                                                                                            * It is updated by timing from the start of the last `Engine.update` call until it ends. * * This value
                                                                                                                                                            will also include the total execution time of all event handlers directly or indirectly triggered by
                                                                                                                                                            the engine update. * * @property timing.lastElapsed * @type number * @default 0 */ /** * A `Number`
                                                                                                                                                            that represents the `delta` value used in the last engine update. * * @property timing.lastDelta *
                                                                                                                                                            @type number * @default 0 */ /** * A `Matter.Detector` instance. * * @property detector * @type detector
                                                                                                                                                            * @default a Matter.Detector instance */ /** * A `Matter.Grid` instance. * * @deprecated replaced by
                                                                                                                                                            `engine.detector` * @property grid * @type grid * @default a Matter.Grid instance */ /** * Replaced
                                                                                                                                                            by and now alias for `engine.grid`. * * @deprecated replaced by `engine.detector` * @property broadphase
                                                                                                                                                            * @type grid * @default a Matter.Grid instance */ /** * The root `Matter.Composite` instance that will
                                                                                                                                                            contain all bodies, constraints and other composites to be simulated by this engine. * * @property
                                                                                                                                                            world * @type composite * @default a Matter.Composite instance */ /** * An object reserved for storing
                                                                                                                                                            plugin-specific properties. * * @property plugin * @type {} */ /** * The gravity to apply on all bodies
                                                                                                                                                            in `engine.world`. * * @property gravity * @type object */ /** * The gravity x component. * * @property
                                                                                                                                                            gravity.x * @type object * @default 0 */ /** * The gravity y component. * * @property gravity.y * @type
                                                                                                                                                            object * @default 1 */ /** * The gravity scale factor. * * @property gravity.scale * @type object *
                                                                                                                                                            @default 0.001 */})()},function(e,t,n){var i={};e.exports=i;var o=n(3);var r=n(1);(function(){i._restingThresh=4;i._restingThreshTangent=6;i._positionDampen=.9;i._positionWarming=.8;i._frictionNormalMultiplier=5;
                                                                                                                                                        /** * Prepare pairs for position solving. * @method preSolvePosition * @param {pair[]} pairs */i.preSolvePosition=function(e){var
                                                                                                                                                            t,n,i,o=e.length;for(t=0;t<o;t++){n=e[t];if(n.isActive){i=n.activeContacts.length;n.collision.parentA.totalContacts+=i;n.collision.parentB.totalContacts+=i}}};
                                                                                                                                                        /** * Find a solution for pair positions. * @method solvePosition * @param {pair[]} pairs * @param
                                                                                                                                                            {number} timeScale */i.solvePosition=function(e,t){var n,o,r,a,s,l,c,u,f=i._positionDampen,d=e.length;for(n=0;n<d;n++){o=e[n];if(o.isActive&&!o.isSensor){r=o.collision;a=r.parentA;s=r.parentB;l=r.normal;o.separation=l.x*(s.positionImpulse.x+r.penetration.x-a.positionImpulse.x)+l.y*(s.positionImpulse.y+r.penetration.y-a.positionImpulse.y)}}for(n=0;n<d;n++){o=e[n];if(o.isActive&&!o.isSensor){r=o.collision;a=r.parentA;s=r.parentB;l=r.normal;u=(o.separation-o.slop)*t;(a.isStatic||s.isStatic)&&(u*=2);if(!(a.isStatic||a.isSleeping)){c=f/a.totalContacts;a.positionImpulse.x+=l.x*u*c;a.positionImpulse.y+=l.y*u*c}if(!(s.isStatic||s.isSleeping)){c=f/s.totalContacts;s.positionImpulse.x-=l.x*u*c;s.positionImpulse.y-=l.y*u*c}}}};
                                                                                                                                                        /** * Apply position resolution. * @method postSolvePosition * @param {body[]} bodies */i.postSolvePosition=function(e){var
                                                                                                                                                            t=i._positionWarming,n=e.length,a=o.translate,s=r.update;for(var l=0;l<n;l++){var c=e[l],u=c.positionImpulse,f=u.x,d=u.y,p=c.velocity;c.totalContacts=0;if(0!==f||0!==d){for(var
                                                                                                                                                            v=0;v<c.parts.length;v++){var y=c.parts[v];a(y.vertices,u);s(y.bounds,y.vertices,p);y.position.x+=f;y.position.y+=d}c.positionPrev.x+=f;c.positionPrev.y+=d;if(f*p.x+d*p.y<0){u.x=0;u.y=0}else{u.x*=t;u.y*=t}}}};
                                                                                                                                                        /** * Prepare pairs for velocity solving. * @method preSolveVelocity * @param {pair[]} pairs */i.preSolveVelocity=function(e){var
                                                                                                                                                            t,n,i=e.length;for(t=0;t<i;t++){var o=e[t];if(o.isActive&&!o.isSensor){var r=o.activeContacts,a=r.length,s=o.collision,l=s.parentA,c=s.parentB,u=s.normal,f=s.tangent;for(n=0;n<a;n++){var
                                                                                                                                                            d=r[n],p=d.vertex,v=d.normalImpulse,y=d.tangentImpulse;if(0!==v||0!==y){var m=u.x*v+f.x*y,g=u.y*v+f.y*y;if(!(l.isStatic||l.isSleeping)){l.positionPrev.x+=m*l.inverseMass;l.positionPrev.y+=g*l.inverseMass;l.anglePrev+=l.inverseInertia*((p.x-l.position.x)*g-(p.y-l.position.y)*m)}if(!(c.isStatic||c.isSleeping)){c.positionPrev.x-=m*c.inverseMass;c.positionPrev.y-=g*c.inverseMass;c.anglePrev-=c.inverseInertia*((p.x-c.position.x)*g-(p.y-c.position.y)*m)}}}}}};
                                                                                                                                                        /** * Find a solution for pair velocities. * @method solveVelocity * @param {pair[]} pairs * @param
                                                                                                                                                            {number} timeScale */i.solveVelocity=function(e,t){var n,o,r,a,s=t*t,l=i._restingThresh*s,c=i._frictionNormalMultiplier,u=i._restingThreshTangent*s,f=Number.MAX_VALUE,d=e.length;for(r=0;r<d;r++){var
                                                                                                                                                            p=e[r];if(p.isActive&&!p.isSensor){var v=p.collision,y=v.parentA,m=v.parentB,g=y.velocity,x=m.velocity,h=v.normal.x,b=v.normal.y,S=v.tangent.x,w=v.tangent.y,_=p.activeContacts,A=_.length,P=1/A,C=y.inverseMass+m.inverseMass,k=p.friction*p.frictionStatic*c*s;g.x=y.position.x-y.positionPrev.x;g.y=y.position.y-y.positionPrev.y;x.x=m.position.x-m.positionPrev.x;x.y=m.position.y-m.positionPrev.y;y.angularVelocity=y.angle-y.anglePrev;m.angularVelocity=m.angle-m.anglePrev;for(a=0;a<A;a++){var
                                                                                                                                                            M=_[a],B=M.vertex;var I=B.x-y.position.x,T=B.y-y.position.y,R=B.x-m.position.x,E=B.y-m.position.y;var
                                                                                                                                                            V=g.x-T*y.angularVelocity,L=g.y+I*y.angularVelocity,q=x.x-E*m.angularVelocity,O=x.y+R*m.angularVelocity;var
                                                                                                                                                            D=V-q,F=L-O;var H=h*D+b*F,j=S*D+w*F;var W=p.separation+H;var G=Math.min(W,1);G=W<0?0:G;var N=G*k;if(j>N||-j>N){o=j>0?j:-j;n=p.friction*(j>0?1:-1)*s;n
                                                                                                                                                            <-o?n=-o:n>o&&(n=o)}else{n=j;o=f}var U=I*b-T*h,z=R*b-E*h,X=P/(C+y.inverseInertia*U*U+m.inverseInertia*z*z);var
                                                                                                                                                                Q=(1+p.restitution)*H*X;n*=X;if(H*H>l&&H
                                                                                                                                                                <0)M.normalImpulse=0;else{var Y=M.normalImpulse;M.normalImpulse+=Q;M.normalImpulse=Math.min(M.normalImpulse,0);Q=M.normalImpulse-Y}if(j*j>u)M.tangentImpulse=0;else{var Z=M.tangentImpulse;M.tangentImpulse+=n;M.tangentImpulse
                                                                                                                                                                    <-o&&(M.tangentImpulse=-o);M.tangentImpulse>o&&(M.tangentImpulse=o);n=M.tangentImpulse-Z}var $=h*Q+S*n,J=b*Q+w*n;if(!(y.isStatic||y.isSleeping)){y.positionPrev.x+=$*y.inverseMass;y.positionPrev.y+=J*y.inverseMass;y.anglePrev+=(I*J-T*$)*y.inverseInertia}if(!(m.isStatic||m.isSleeping)){m.positionPrev.x-=$*m.inverseMass;m.positionPrev.y-=J*m.inverseMass;m.anglePrev-=(R*J-E*$)*m.inverseInertia}}}}}})()},function(e,t,n){var
                                                                                                                                                                        i={};e.exports=i;var o=n(9);var r=n(0);(function(){ /** * Creates a new pairs structure.
                                                                                                                                                                        * @method create * @param {object} options * @return {pairs} A new pairs structure
                                                                                                                                                                        */ i.create=function(e){return r.extend({table:{},list:[],collisionStart:[],collisionActive:[],collisionEnd:[]},e)};
                                                                                                                                                                        /** * Updates pairs given a list of collisions. * @method update * @param {object}
                                                                                                                                                                        pairs * @param {collision[]} collisions * @param {number} timestamp */i.update=function(e,t,n){var
                                                                                                                                                                        i,r,a,s,l=e.list,c=l.length,u=e.table,f=t.length,d=e.collisionStart,p=e.collisionEnd,v=e.collisionActive;d.length=0;p.length=0;v.length=0;for(s=0;s
                                                                                                                                                                        <c;s++)l[s].confirmedActive=false;for(s=0;s<f;s++){i=t[s];a=i.pair;if(a){a.isActive?v.push(a):d.push(a);o.update(a,i,n);a.confirmedActive=true}else{a=o.create(i,n);u[a.id]=a;d.push(a);l.push(a)}}var
                                                                                                                                                                            y=[];c=l.length;for(s=0;s<c;s++){a=l[s];if(!a.confirmedActive){o.setActive(a,false,n);p.push(a);a.collision.bodyA.isSleeping||a.collision.bodyB.isSleeping||y.push(s)}}for(s=0;s<y.length;s++){r=y[s]-s;a=l[r];l.splice(r,1);delete
                                                                                                                                                                            u[a.id]}}; /** * Clears the given pairs structure. * @method clear * @param {pairs}
                                                                                                                                                                            pairs * @return {pairs} pairs */i.clear=function(e){e.table={};e.list.length=0;e.collisionStart.length=0;e.collisionActive.length=0;e.collisionEnd.length=0;return
                                                                                                                                                                            e}})()},function(e,t,n){var i=e.exports=n(22);i.Axes=n(11);i.Bodies=n(12);i.Body=n(6);i.Bounds=n(1);i.Collision=n(8);i.Common=n(0);i.Composite=n(5);i.Composites=n(23);i.Constraint=n(10);i.Contact=n(17);i.Detector=n(14);i.Engine=n(18);i.Events=n(4);i.Grid=n(24);i.Mouse=n(13);i.MouseConstraint=n(25);i.Pair=n(9);i.Pairs=n(20);i.Plugin=n(15);i.Query=n(26);i.Render=n(16);i.Resolver=n(19);i.Runner=n(27);i.SAT=n(28);i.Sleeping=n(7);i.Svg=n(29);i.Vector=n(2);i.Vertices=n(3);i.World=n(30);i.Engine.run=i.Runner.run;i.Common.deprecated(i.Engine,
                                                                                                                                                                            "run", "Engine.run âž¤ use Matter.Runner.run(engine) instead")},function(e,t,n){var i={};e.exports=i;var
                                                                                                                                                                            o=n(15);var r=n(0);(function(){ /** * The library name. * @property name * @readOnly
                                                                                                                                                                            * @type {String} */ i.name="matter-js" ; /** * The library version. * @property version
                                                                                                                                                                            * @readOnly * @type {String} */i.version="0.18.0" ; /** * A list of plugin dependencies
                                                                                                                                                                            to be installed. These are normally set and installed through `Matter.use`. * Alternatively
                                                                                                                                                                            you may set `Matter.uses` manually and install them by calling `Plugin.use(Matter)`.
                                                                                                                                                                            * @property uses * @type {Array} */i.uses=[]; /** * The plugins that have been installed
                                                                                                                                                                            through `Matter.Plugin.install`. Read only. * @property used * @readOnly * @type {Array}
                                                                                                                                                                            */i.used=[]; /** * Installs the given plugins on the `Matter` namespace. * This is
                                                                                                                                                                            a short-hand for `Plugin.use`, see it for more information. * Call this function once
                                                                                                                                                                            at the start of your code, with all of the plugins you wish to install as arguments.
                                                                                                                                                                            * Avoid calling this function multiple times unless you intend to manually control
                                                                                                                                                                            installation order. * @method use * @param ...plugin {Function} The plugin(s) to install
                                                                                                                                                                            on `base` (multi-argument). */i.use=function(){o.use(i,Array.prototype.slice.call(arguments))};
                                                                                                                                                                        /** * Chains a function to excute before the original function on the given `path`
                                                                                                                                                                            relative to `Matter`. * See also docs for `Common.chain`. * @method before * @param
                                                                                                                                                                            {string} path The path relative to `Matter` * @param {function} func The function to
                                                                                                                                                                            chain before the original * @return {function} The chained function that replaced the
                                                                                                                                                                            original */i.before=function(e,t){e=e.replace(/^Matter./, "");return r.chainPathBefore(i,e,t)};
                                                                                                                                                                        /** * Chains a function to excute after the original function on the given `path` relative
                                                                                                                                                                            to `Matter`. * See also docs for `Common.chain`. * @method after * @param {string}
                                                                                                                                                                            path The path relative to `Matter` * @param {function} func The function to chain after
                                                                                                                                                                            the original * @return {function} The chained function that replaced the original */i.after=function(e,t){e=e.replace(/^Matter./,
                                                                                                                                                                            "");return r.chainPathAfter(i,e,t)}})()},function(e,t,n){var i={};e.exports=i;var o=n(5);var
                                                                                                                                                                            r=n(10);var a=n(0);var s=n(6);var l=n(12);var c=a.deprecated;(function(){ /** * Create
                                                                                                                                                                            a new composite containing bodies created in the callback in a grid arrangement. *
                                                                                                                                                                            This function uses the body 's bounds to prevent overlaps.
         * @method stack
         * @param {number} xx
         * @param {number} yy
         * @param {number} columns
         * @param {number} rows
         * @param {number} columnGap
         * @param {number} rowGap
         * @param {function} callback
         * @return {composite} A new composite containing objects created in the callback
         */
i.stack=function(e,t,n,i,r,a,l){var c,u=o.create({label:"Stack"}),f=e,d=t,p=0;for(var v=0;v<i;v++){var y=0;for(var m=0;m<n;m++){var g=l(f,d,m,v,c,p);if(g){var x=g.bounds.max.y-g.bounds.min.y,h=g.bounds.max.x-g.bounds.min.x;x>y&&(y=x);s.translate(g,{x:.5*h,y:.5*x});f=g.bounds.max.x+r;o.addBody(u,g);c=g;p+=1}else f+=r}d+=y+a;f=e}return u};
/**
         * Chains all bodies in the given composite together using constraints.
         * @method chain
         * @param {composite} composite
         * @param {number} xOffsetA
         * @param {number} yOffsetA
         * @param {number} xOffsetB
         * @param {number} yOffsetB
         * @param {object} options
         * @return {composite} A new composite containing objects chained together with constraints
         */i.chain=function(e,t,n,i,s,l){var c=e.bodies;for(var u=1;u<c.length;u++){var f=c[u-1],d=c[u],p=f.bounds.max.y-f.bounds.min.y,v=f.bounds.max.x-f.bounds.min.x,y=d.bounds.max.y-d.bounds.min.y,m=d.bounds.max.x-d.bounds.min.x;var g={bodyA:f,pointA:{x:v*t,y:p*n},bodyB:d,pointB:{x:m*i,y:y*s}};var x=a.extend(g,l);o.addConstraint(e,r.create(x))}e.label+=" Chain";return e};
/**
         * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.
         * @method mesh
         * @param {composite} composite
         * @param {number} columns
         * @param {number} rows
         * @param {boolean} crossBrace
         * @param {object} options
         * @return {composite} The composite containing objects meshed together with constraints
         */i.mesh=function(e,t,n,i,s){var l,c,u,f,d,p=e.bodies;for(l=0;l<n;l++){for(c=1;c<t;c++){u=p[c-1+l*t];f=p[c+l*t];o.addConstraint(e,r.create(a.extend({bodyA:u,bodyB:f},s)))}if(l>0)for(c=0;c<t;c++){u=p[c+(l-1)*t];f=p[c+l*t];o.addConstraint(e,r.create(a.extend({bodyA:u,bodyB:f},s)));if(i&&c>0){d=p[c-1+(l-1)*t];o.addConstraint(e,r.create(a.extend({bodyA:d,bodyB:f},s)))}if(i&&c<t-1){d=p[c+1+(l-1)*t];o.addConstraint(e,r.create(a.extend({bodyA:d,bodyB:f},s)))}}}e.label+=" Mesh";return e};
/**
         * Create a new composite containing bodies created in the callback in a pyramid arrangement.
         * This function uses the body's bounds to prevent overlaps. * @method pyramid * @param {number} xx * @param {number} yy * @param {number} columns * @param {number} rows * @param {number} columnGap * @param {number} rowGap * @param {function}
                                                                                                                                                                            callback * @return {composite} A new composite containing objects created in the callback
                                                                                                                                                                            */i.pyramid=function(e,t,n,o,r,a,l){return i.stack(e,t,n,o,r,a,(function(t,i,a,c,u,f){var
                                                                                                                                                                            d=Math.min(o,Math.ceil(n/2)),p=u?u.bounds.max.x-u.bounds.min.x:0;if(!(c>d)){c=d-c;var v=c,y=n-1-c;if(!(a
                                                                                                                                                                            <v||a>y)){1===f&&s.translate(u,{x:(a+(n%2===1?1:-1))*p,y:0});var m=u?a*p:0;return l(e+m+a*r,i,a,c,u,f)}}}))};
                                                                                                                                                                                /** * This has now moved to the [newtonsCradle example](https://github.com/liabru/matter-js/blob/master/examples/newtonsCradle.js),
                                                                                                                                                                                follow that instead as this function is deprecated here. * @deprecated moved
                                                                                                                                                                                to newtonsCradle example * @method newtonsCradle * @param {number} xx * @param
                                                                                                                                                                                {number} yy * @param {number} number * @param {number} size * @param {number}
                                                                                                                                                                                length * @return {composite} A new composite newtonsCradle body */i.newtonsCradle=function(e,t,n,i,a){var
                                                                                                                                                                                s=o.create({label:"Newtons Cradle"});for(var c=0;c
                                                                                                                                                                                <n;c++){var u=1.9,f=l.circle(e+c*(i*u),t+a,i,{inertia:Infinity,restitution:1,friction:0,frictionAir:1e-4,slop:1}),d=r.create({pointA:{x:e+c*(i*u),y:t},bodyB:f});o.addBody(s,f);o.addConstraint(s,d)}return
                                                                                                                                                                                    s};c(i, "newtonsCradle",
                                                                                                                                                                                    "Composites.newtonsCradle âž¤ moved to newtonsCradle example"); /** * This has now moved to the [car example](https://github.com/liabru/matter-js/blob/master/examples/car.js),
                                                                                                                                                                                    follow that instead as this function is deprecated here. * @deprecated moved
                                                                                                                                                                                    to car example * @method car * @param {number} xx * @param {number} yy * @param
                                                                                                                                                                                    {number} width * @param {number} height * @param {number} wheelSize * @return
                                                                                                                                                                                    {composite} A new composite car body */i.car=function(e,t,n,i,a){var c=s.nextGroup(true),u=20,f=.5*-n+u,d=.5*n-u,p=0;var
                                                                                                                                                                                    v=o.create({label: "Car"}),y=l.rectangle(e,t,n,i,{collisionFilter:{group:c},chamfer:{radius:.5*i},density:2e-4});var
                                                                                                                                                                                    m=l.circle(e+f,t+p,a,{collisionFilter:{group:c},friction:.8});var g=l.circle(e+d,t+p,a,{collisionFilter:{group:c},friction:.8});var
                                                                                                                                                                                    x=r.create({bodyB:y,pointB:{x:f,y:p},bodyA:m,stiffness:1,length:0});var h=r.create({bodyB:y,pointB:{x:d,y:p},bodyA:g,stiffness:1,length:0});o.addBody(v,y);o.addBody(v,m);o.addBody(v,g);o.addConstraint(v,x);o.addConstraint(v,h);return
                                                                                                                                                                                    v};c(i, "car", "Composites.car âž¤ moved to car example"); /** * This has now
                                                                                                                                                                                    moved to the [softBody example](https://github.com/liabru/matter-js/blob/master/examples/softBody.js)
                                                                                                                                                                                    * and the [cloth example](https://github.com/liabru/matter-js/blob/master/examples/cloth.js),
                                                                                                                                                                                    follow those instead as this function is deprecated here. * @deprecated moved
                                                                                                                                                                                    to softBody and cloth examples * @method softBody * @param {number} xx * @param
                                                                                                                                                                                    {number} yy * @param {number} columns * @param {number} rows * @param {number}
                                                                                                                                                                                    columnGap * @param {number} rowGap * @param {boolean} crossBrace * @param {number}
                                                                                                                                                                                    particleRadius * @param {} particleOptions * @param {} constraintOptions *
                                                                                                                                                                                    @return {composite} A new composite softBody */i.softBody=function(e,t,n,o,r,s,c,u,f,d){f=a.extend({inertia:Infinity},f);d=a.extend({stiffness:.2,render:{type:
                                                                                                                                                                                    "line",anchors:false}},d);var p=i.stack(e,t,n,o,r,s,(function(e,t){return l.circle(e,t,u,f)}));i.mesh(p,n,o,c,d);p.label="Soft Body"
                                                                                                                                                                                    ;return p};c(i, "softBody",
                                                                                                                                                                                    "Composites.softBody âž¤ moved to softBody and cloth examples")})()},function(e,t,n){ /** * This module has now been replaced by `Matter.Detector`.
                                                                                                                                                                                    * * All usage should be migrated to `Matter.Detector` or another alternative.
                                                                                                                                                                                    * For back-compatibility purposes this module will remain for a short term
                                                                                                                                                                                    and then later removed in a future release. * * The `Matter.Grid` module contains
                                                                                                                                                                                    methods for creating and manipulating collision broadphase grid structures.
                                                                                                                                                                                    * * @class Grid * @deprecated */ var i={};e.exports=i;var o=n(9);var r=n(0);var
                                                                                                                                                                                    a=r.deprecated;(function(){ /** * Creates a new grid. * @deprecated replaced
                                                                                                                                                                                    by Matter.Detector * @method create * @param {} options * @return {grid} A
                                                                                                                                                                                    new grid */ i.create=function(e){var t={buckets:{},pairs:{},pairsList:[],bucketWidth:48,bucketHeight:48};return
                                                                                                                                                                                    r.extend(t,e)}; /** * The width of a single grid bucket. * * @property bucketWidth
                                                                                                                                                                                    * @type number * @default 48 */ /** * The height of a single grid bucket. *
                                                                                                                                                                                    * @property bucketHeight * @type number * @default 48 */ /** * Updates the
                                                                                                                                                                                    grid. * @deprecated replaced by Matter.Detector * @method update * @param {grid}
                                                                                                                                                                                    grid * @param {body[]} bodies * @param {engine} engine * @param {boolean} forceUpdate
                                                                                                                                                                                    */i.update=function(e,t,n,o){var r,a,s,l,c,u=n.world,f=e.buckets,d=false;for(r=0;r<t.length;r++){var
                                                                                                                                                                                    p=t[r];if((!p.isSleeping||o)&&(!u.bounds||!(p.bounds.max.x<u.bounds.min.x||p.bounds.min.x>u.bounds.max.x||p.bounds.max.y
                                                                                                                                                                                    <u.bounds.min.y||p.bounds.min.y>u.bounds.max.y))){var v=i._getRegion(e,p);if(!p.region||v.id!==p.region.id||o){p.region&&!o||(p.region=v);var
                                                                                                                                                                                        y=i._regionUnion(v,p.region);for(a=y.startCol;a
                                                                                                                                                                                        <=y.endCol;a++)for(s=y.startRow;s<=y.endRow;s++){c=i._getBucketId(a,s);l=f[c];var
                                                                                                                                                                                            m=a>=v.startCol&&a
                                                                                                                                                                                            <=v.endCol&&s>=v.startRow&&s
                                                                                                                                                                                                <=v.endRow;var g=a>=p.region.startCol&&a
                                                                                                                                                                                                    <=p.region.endCol&&s>=p.region.startRow&&s
                                                                                                                                                                                                        <=p.region.endRow;!m&&g&&g&&l&&i._bucketRemoveBody(e,l,p);if(p.region===v||m&&!g||o){l||(l=i._createBucket(f,c));i._bucketAddBody(e,l,p)}}p.region=v;d=true}}}d&&(e.pairsList=i._createActivePairsList(e))};a(i,
                                                                                                                                                                                                            "update", "Grid.update âž¤ replaced by Matter.Detector"); /**
                                                                                                                                                                                                            * Clears the grid. * @deprecated replaced by Matter.Detector
                                                                                                                                                                                                            * @method clear * @param {grid} grid */i.clear=function(e){e.buckets={};e.pairs={};e.pairsList=[]};a(i,
                                                                                                                                                                                                            "clear", "Grid.clear âž¤ replaced by Matter.Detector"); /**
                                                                                                                                                                                                            * Finds the union of two regions. * @method _regionUnion
                                                                                                                                                                                                            * @deprecated replaced by Matter.Detector * @private
                                                                                                                                                                                                            * @param {} regionA * @param {} regionB * @return {}
                                                                                                                                                                                                            region */i._regionUnion=function(e,t){var n=Math.min(e.startCol,t.startCol),o=Math.max(e.endCol,t.endCol),r=Math.min(e.startRow,t.startRow),a=Math.max(e.endRow,t.endRow);return
                                                                                                                                                                                                            i._createRegion(n,o,r,a)}; /** * Gets the region a
                                                                                                                                                                                                            given body falls in for a given grid. * @method _getRegion
                                                                                                                                                                                                            * @deprecated replaced by Matter.Detector * @private
                                                                                                                                                                                                            * @param {} grid * @param {} body * @return {} region
                                                                                                                                                                                                            */i._getRegion=function(e,t){var n=t.bounds,o=Math.floor(n.min.x/e.bucketWidth),r=Math.floor(n.max.x/e.bucketWidth),a=Math.floor(n.min.y/e.bucketHeight),s=Math.floor(n.max.y/e.bucketHeight);return
                                                                                                                                                                                                            i._createRegion(o,r,a,s)}; /** * Creates a region.
                                                                                                                                                                                                            * @method _createRegion * @deprecated replaced by Matter.Detector
                                                                                                                                                                                                            * @private * @param {} startCol * @param {} endCol
                                                                                                                                                                                                            * @param {} startRow * @param {} endRow * @return {}
                                                                                                                                                                                                            region */i._createRegion=function(e,t,n,i){return{id:e+
                                                                                                                                                                                                            ","+t+ ","+n+ ","+i,startCol:e,endCol:t,startRow:n,endRow:i}};
                                                                                                                                                                                                        /** * Gets the bucket id at the given position. * @method
                                                                                                                                                                                                            _getBucketId * @deprecated replaced by Matter.Detector
                                                                                                                                                                                                            * @private * @param {} column * @param {} row * @return
                                                                                                                                                                                                            {string} bucket id */i._getBucketId=function(e,t){return
                                                                                                                                                                                                            "C"+e+ "R"+t}; /** * Creates a bucket. * @method _createBucket
                                                                                                                                                                                                            * @deprecated replaced by Matter.Detector * @private
                                                                                                                                                                                                            * @param {} buckets * @param {} bucketId * @return
                                                                                                                                                                                                            {} bucket */i._createBucket=function(e,t){var n=e[t]=[];return
                                                                                                                                                                                                            n}; /** * Adds a body to a bucket. * @method _bucketAddBody
                                                                                                                                                                                                            * @deprecated replaced by Matter.Detector * @private
                                                                                                                                                                                                            * @param {} grid * @param {} bucket * @param {} body
                                                                                                                                                                                                            */i._bucketAddBody=function(e,t,n){var i,r=e.pairs,a=o.id,s=t.length;for(i=0;i<s;i++){var
                                                                                                                                                                                                            l=t[i];if(!(n.id===l.id||n.isStatic&&l.isStatic)){var
                                                                                                                                                                                                            c=a(n,l),u=r[c];u?u[2]+=1:r[c]=[n,l,1]}}t.push(n)};
                                                                                                                                                                                                        /** * Removes a body from a bucket. * @method _bucketRemoveBody
                                                                                                                                                                                                            * @deprecated replaced by Matter.Detector * @private
                                                                                                                                                                                                            * @param {} grid * @param {} bucket * @param {} body
                                                                                                                                                                                                            */i._bucketRemoveBody=function(e,t,n){var i,a=e.pairs,s=o.id;t.splice(r.indexOf(t,n),1);var
                                                                                                                                                                                                            l=t.length;for(i=0;i<l;i++){var c=a[s(n,t[i])];c&&(c[2]-=1)}};
                                                                                                                                                                                                        /** * Generates a list of the active pairs in the grid.
                                                                                                                                                                                                            * @method _createActivePairsList * @deprecated replaced
                                                                                                                                                                                                            by Matter.Detector * @private * @param {} grid * @return
                                                                                                                                                                                                            [] pairs */i._createActivePairsList=function(e){var
                                                                                                                                                                                                            t,n,i=e.pairs,o=r.keys(i),a=o.length,s=[];for(n=0;n<a;n++){t=i[o[n]];t[2]>0?s.push(t):delete i[o[n]]}return s}})()},function(e,t,n){var
                                                                                                                                                                                                            i={};e.exports=i;var o=n(3);var r=n(7);var a=n(13);var
                                                                                                                                                                                                            s=n(4);var l=n(14);var c=n(10);var u=n(5);var f=n(0);var
                                                                                                                                                                                                            d=n(1);(function(){ /** * Creates a new mouse constraint.
                                                                                                                                                                                                            * All properties have default values, and many
                                                                                                                                                                                                            are pre-calculated automatically based on other
                                                                                                                                                                                                            properties. * See the properties section below
                                                                                                                                                                                                            for detailed information on what you can pass via
                                                                                                                                                                                                            the `options` object. * @method create * @param
                                                                                                                                                                                                            {engine} engine * @param {} options * @return {MouseConstraint}
                                                                                                                                                                                                            A new MouseConstraint */ i.create=function(e,t){var
                                                                                                                                                                                                            n=(e?e.mouse:null)||(t?t.mouse:null);if(!n)if(e&&e.render&&e.render.canvas)n=a.create(e.render.canvas);else
                                                                                                                                                                                                            if(t&&t.element)n=a.create(t.element);else{n=a.create();f.warn("MouseConstraint.create:
                                                                                                                                                                                                            options.mouse was undefined, options.element was
                                                                                                                                                                                                            undefined, may not function as expected")}var o=c.create({label:"Mouse
                                                                                                                                                                                                            Constraint",pointA:n.position,pointB:{x:0,y:0},length:.01,stiffness:.1,angularStiffness:1,render:{strokeStyle:"#90EE90",lineWidth:3}});var
                                                                                                                                                                                                            r={type:"mouseConstraint",mouse:n,element:null,body:null,constraint:o,collisionFilter:{category:1,mask:4294967295,group:0}};var
                                                                                                                                                                                                            l=f.extend(r,t);s.on(e,"beforeUpdate",(function(){var
                                                                                                                                                                                                            t=u.allBodies(e.world);i.update(l,t);i._triggerEvents(l)}));return
                                                                                                                                                                                                            l}; /** * Updates the given mouse constraint. *
                                                                                                                                                                                                            @private * @method update * @param {MouseConstraint}
                                                                                                                                                                                                            mouseConstraint * @param {body[]} bodies */i.update=function(e,t){var
                                                                                                                                                                                                            n=e.mouse,i=e.constraint,a=e.body;if(0===n.button)if(i.bodyB){r.set(i.bodyB,false);i.pointA=n.position}else
                                                                                                                                                                                                            for(var c=0;c
                                                                                                                                                                                                            <t.length;c++){a=t[c];if(d.contains(a.bounds,n.position)&&l.canCollide(a.collisionFilter,e.collisionFilter))for(var
                                                                                                                                                                                                                u=a.parts.length>1?1:0;u
                                                                                                                                                                                                                <a.parts.length;u++){var f=a.parts[u];if(o.contains(f.vertices,n.position)){i.pointA=n.position;i.bodyB=e.body=a;i.pointB={x:n.position.x-a.position.x,y:n.position.y-a.position.y};i.angleB=a.angle;r.set(a,false);s.trigger(e,
                                                                                                                                                                                                                    "startdrag",{mouse:n,body:a});break}}}else{i.bodyB=e.body=null;i.pointB=null;a&&s.trigger(e,
                                                                                                                                                                                                                    "enddrag",{mouse:n,body:a})}}; /** * Triggers mouse
                                                                                                                                                                                                                    constraint events. * @method _triggerEvents
                                                                                                                                                                                                                    * @private * @param {mouse} mouseConstraint
                                                                                                                                                                                                                    */i._triggerEvents=function(e){var t=e.mouse,n=t.sourceEvents;n.mousemove&&s.trigger(e,
                                                                                                                                                                                                                    "mousemove",{mouse:t});n.mousedown&&s.trigger(e,
                                                                                                                                                                                                                    "mousedown",{mouse:t});n.mouseup&&s.trigger(e,
                                                                                                                                                                                                                    "mouseup",{mouse:t});a.clearSourceEvents(t)}; /** *
                                                                                                                                                                                                                    Fired when the mouse has moved (or a touch
                                                                                                                                                                                                                    moves) during the last step * * @event mousemove
                                                                                                                                                                                                                    * @param {} event An event object * @param
                                                                                                                                                                                                                    {mouse} event.mouse The engine 's mouse instance
        * @param {} event.source The source object of the event
        * @param {} event.name The name of the event
        */
/**
        * Fired when the mouse is down (or a touch has started) during the last step
        *
        * @event mousedown
        * @param {} event An event object
        * @param {mouse} event.mouse The engine's mouse instance * @param {} event.source The source object of the event * @param {} event.name The name of the event */ /** * Fired when the mouse is up (or a touch has ended) during the last step * *
                                                                                                                                                                                                                    @event mouseup * @param {} event An event object
                                                                                                                                                                                                                    * @param {mouse} event.mouse The engine 's mouse instance
        * @param {} event.source The source object of the event
        * @param {} event.name The name of the event
        */
/**
        * Fired when the user starts dragging a body
        *
        * @event startdrag
        * @param {} event An event object
        * @param {mouse} event.mouse The engine's mouse instance * @param {body} event.body The body being dragged * @param {} event.source The source object of the event * @param {} event.name The name of the event */ /** * Fired when the user ends
                                                                                                                                                                                                                    dragging a body * * @event enddrag * @param
                                                                                                                                                                                                                    {} event An event object * @param {mouse} event.mouse
                                                                                                                                                                                                                    The engine 's mouse instance
        * @param {body} event.body The body that has stopped being dragged
        * @param {} event.source The source object of the event
        * @param {} event.name The name of the event
        */
/**
         * A `String` denoting the type of object.
         *
         * @property type
         * @type string
         * @default "constraint"
         * @readOnly
         */
/**
         * The `Mouse` instance in use. If not supplied in `MouseConstraint.create`, one will be created.
         *
         * @property mouse
         * @type mouse
         * @default mouse
         */
/**
         * The `Body` that is currently being moved by the user, or `null` if no body.
         *
         * @property body
         * @type body
         * @default null
         */
/**
         * The `Constraint` object that is used to move the body during interaction.
         *
         * @property constraint
         * @type constraint
         */
/**
         * An `Object` that specifies the collision filter properties.
         * The collision filter allows the user to define which types of body this mouse constraint can interact with.
         * See `body.collisionFilter` for more information.
         *
         * @property collisionFilter
         * @type object
         */})()},function(e,t,n){var i={};e.exports=i;var o=n(2);var r=n(8);var a=n(1);var s=n(12);var l=n(3);(function(){
/**
         * Returns a list of collisions between `body` and `bodies`.
         * @method collides
         * @param {body} body
         * @param {body[]} bodies
         * @return {collision[]} Collisions
         */
i.collides=function(e,t){var n=[],i=t.length,o=e.bounds,s=r.collides,l=a.overlaps;for(var c=0;c<i;c++){var u=t[c],f=u.parts.length,d=1===f?0:1;if(l(u.bounds,o))for(var p=d;p<f;p++){var v=u.parts[p];if(l(v.bounds,o)){var y=s(v,e);if(y){n.push(y);break}}}}return n};
/**
         * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.
         * @method ray
         * @param {body[]} bodies
         * @param {vector} startPoint
         * @param {vector} endPoint
         * @param {number} [rayWidth]
         * @return {collision[]} Collisions
         */i.ray=function(e,t,n,r){r=r||1e-100;var a=o.angle(t,n),l=o.magnitude(o.sub(t,n)),c=.5*(n.x+t.x),u=.5*(n.y+t.y),f=s.rectangle(c,u,l,r,{angle:a}),d=i.collides(f,e);for(var p=0;p<d.length;p+=1){var v=d[p];v.body=v.bodyB=v.bodyA}return d};
/**
         * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.
         * @method region
         * @param {body[]} bodies
         * @param {bounds} bounds
         * @param {bool} [outside=false]
         * @return {body[]} The bodies matching the query
         */i.region=function(e,t,n){var i=[];for(var o=0;o<e.length;o++){var r=e[o],s=a.overlaps(r.bounds,t);(s&&!n||!s&&n)&&i.push(r)}return i};
/**
         * Returns all bodies whose vertices contain the given point, from the given set of bodies.
         * @method point
         * @param {body[]} bodies
         * @param {vector} point
         * @return {body[]} The bodies matching the query
         */i.point=function(e,t){var n=[];for(var i=0;i<e.length;i++){var o=e[i];if(a.contains(o.bounds,t))for(var r=1===o.parts.length?0:1;r<o.parts.length;r++){var s=o.parts[r];if(a.contains(s.bounds,t)&&l.contains(s.vertices,t)){n.push(o);break}}}return n}})()},function(e,t,n){var i={};e.exports=i;var o=n(4);var r=n(18);var a=n(0);(function(){var e,t;if("undefined"!==typeof window){e=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.msRequestAnimationFrame;t=window.cancelAnimationFrame||window.mozCancelAnimationFrame||window.webkitCancelAnimationFrame||window.msCancelAnimationFrame}if(!e){var n;e=function(e){n=setTimeout((function(){e(a.now())}),1e3/60)};t=function(){clearTimeout(n)}}
/**
         * Creates a new Runner. The options parameter is an object that specifies any properties you wish to override the defaults.
         * @method create
         * @param {} options
         */i.create=function(e){var t={fps:60,correction:1,deltaSampleSize:60,counterTimestamp:0,frameCounter:0,deltaHistory:[],timePrev:null,timeScalePrev:1,frameRequestId:null,isFixed:false,enabled:true};var n=a.extend(t,e);n.delta=n.delta||1e3/n.fps;n.deltaMin=n.deltaMin||1e3/n.fps;n.deltaMax=n.deltaMax||1e3/(.5*n.fps);n.fps=1e3/n.delta;return n};
/**
         * Continuously ticks a `Matter.Engine` by calling `Runner.tick` on the `requestAnimationFrame` event.
         * @method run
         * @param {engine} engine
         */i.run=function(t,n){if("undefined"!==typeof t.positionIterations){n=t;t=i.create()}(function render(o){t.frameRequestId=e(render);o&&t.enabled&&i.tick(t,n,o)})();return t};
/**
         * A game loop utility that updates the engine and renderer by one step (a 'tick ').
         * Features delta smoothing, time correction and fixed or dynamic timing.
         * Consider just `Engine.update(engine, delta)` if you're using your own loop. * @method tick * @param {runner} runner * @param {engine} engine * @param {number} time */i.tick=function(e,t,n){var i,a=t.timing,s=1;var l={timestamp:a.timestamp};o.trigger(e,
                                                                                                                                                                                                                    "beforeTick",l);if(e.isFixed)i=e.delta;else{i=n-e.timePrev||e.delta;e.timePrev=n;e.deltaHistory.push(i);e.deltaHistory=e.deltaHistory.slice(-e.deltaSampleSize);i=Math.min.apply(null,e.deltaHistory);i=i<e.deltaMin?e.deltaMin:i;i=i>e.deltaMax?e.deltaMax:i;s=i/e.delta;e.delta=i}0!==e.timeScalePrev&&(s*=a.timeScale/e.timeScalePrev);0===a.timeScale&&(s=0);e.timeScalePrev=a.timeScale;e.correction=s;e.frameCounter+=1;if(n-e.counterTimestamp>=1e3){e.fps=e.frameCounter*((n-e.counterTimestamp)/1e3);e.counterTimestamp=n;e.frameCounter=0}o.trigger(e,"tick",l);o.trigger(e,"beforeUpdate",l);r.update(t,i,s);o.trigger(e,"afterUpdate",l);o.trigger(e,"afterTick",l)};
                                                                                                                                                                                                                    /** * Ends execution of `Runner.run` on
                                                                                                                                                                                                                    the given `runner`, by canceling the animation
                                                                                                                                                                                                                    frame request event loop. * If you wish
                                                                                                                                                                                                                    to only temporarily pause the engine, see
                                                                                                                                                                                                                    `engine.enabled` instead. * @method stop
                                                                                                                                                                                                                    * @param {runner} runner */i.stop=function(e){t(e.frameRequestId)};
                                                                                                                                                                                                                    /** * Alias for `Runner.run`. * @method
                                                                                                                                                                                                                    start * @param {runner} runner * @param
                                                                                                                                                                                                                    {engine} engine */i.start=function(e,t){i.run(e,t)};
                                                                                                                                                                                                                    /** * Fired at the start of a tick, before
                                                                                                                                                                                                                    any updates to the engine or timing * *
                                                                                                                                                                                                                    @event beforeTick * @param {} event An
                                                                                                                                                                                                                    event object * @param {number} event.timestamp
                                                                                                                                                                                                                    The engine.timing.timestamp of the event
                                                                                                                                                                                                                    * @param {} event.source The source object
                                                                                                                                                                                                                    of the event * @param {} event.name The
                                                                                                                                                                                                                    name of the event */ /** * Fired after
                                                                                                                                                                                                                    engine timing updated, but just before
                                                                                                                                                                                                                    update * * @event tick * @param {} event
                                                                                                                                                                                                                    An event object * @param {number} event.timestamp
                                                                                                                                                                                                                    The engine.timing.timestamp of the event
                                                                                                                                                                                                                    * @param {} event.source The source object
                                                                                                                                                                                                                    of the event * @param {} event.name The
                                                                                                                                                                                                                    name of the event */ /** * Fired at the
                                                                                                                                                                                                                    end of a tick, after engine update and
                                                                                                                                                                                                                    after rendering * * @event afterTick *
                                                                                                                                                                                                                    @param {} event An event object * @param
                                                                                                                                                                                                                    {number} event.timestamp The engine.timing.timestamp
                                                                                                                                                                                                                    of the event * @param {} event.source The
                                                                                                                                                                                                                    source object of the event * @param {}
                                                                                                                                                                                                                    event.name The name of the event */ /**
                                                                                                                                                                                                                    * Fired before update * * @event beforeUpdate
                                                                                                                                                                                                                    * @param {} event An event object * @param
                                                                                                                                                                                                                    {number} event.timestamp The engine.timing.timestamp
                                                                                                                                                                                                                    of the event * @param {} event.source The
                                                                                                                                                                                                                    source object of the event * @param {}
                                                                                                                                                                                                                    event.name The name of the event */ /**
                                                                                                                                                                                                                    * Fired after update * * @event afterUpdate
                                                                                                                                                                                                                    * @param {} event An event object * @param
                                                                                                                                                                                                                    {number} event.timestamp The engine.timing.timestamp
                                                                                                                                                                                                                    of the event * @param {} event.source The
                                                                                                                                                                                                                    source object of the event * @param {}
                                                                                                                                                                                                                    event.name The name of the event */ /**
                                                                                                                                                                                                                    * A flag that specifies whether the runner
                                                                                                                                                                                                                    is running or not. * * @property enabled
                                                                                                                                                                                                                    * @type boolean * @default true */ /**
                                                                                                                                                                                                                    * A `Boolean` that specifies if the runner
                                                                                                                                                                                                                    should use a fixed timestep (otherwise
                                                                                                                                                                                                                    it is variable). * If timing is fixed,
                                                                                                                                                                                                                    then the apparent simulation speed will
                                                                                                                                                                                                                    change depending on the frame rate (but
                                                                                                                                                                                                                    behaviour will be deterministic). * If
                                                                                                                                                                                                                    the timing is variable, then the apparent
                                                                                                                                                                                                                    simulation speed will be constant (approximately,
                                                                                                                                                                                                                    but at the cost of determininism). * *
                                                                                                                                                                                                                    @property isFixed * @type boolean * @default
                                                                                                                                                                                                                    false */ /** * A `Number` that specifies
                                                                                                                                                                                                                    the time step between updates in milliseconds.
                                                                                                                                                                                                                    * If `engine.timing.isFixed` is set to
                                                                                                                                                                                                                    `true`, then `delta` is fixed. * If it
                                                                                                                                                                                                                    is `false`, then `delta` can dynamically
                                                                                                                                                                                                                    change to maintain the correct apparent
                                                                                                                                                                                                                    simulation speed. * * @property delta *
                                                                                                                                                                                                                    @type number * @default 1000 / 60 */})()},function(e,t,n){
                                                                                                                                                                                                                    /** * This module has now been replaced
                                                                                                                                                                                                                    by `Matter.Collision`. * * All usage should
                                                                                                                                                                                                                    be migrated to `Matter.Collision`. * For
                                                                                                                                                                                                                    back-compatibility purposes this module
                                                                                                                                                                                                                    will remain for a short term and then later
                                                                                                                                                                                                                    removed in a future release. * * The `Matter.SAT`
                                                                                                                                                                                                                    module contains methods for detecting collisions
                                                                                                                                                                                                                    using the Separating Axis Theorem. * *
                                                                                                                                                                                                                    @class SAT * @deprecated */ var i={};e.exports=i;var
                                                                                                                                                                                                                    o=n(8);var r=n(0);var a=r.deprecated;(function(){
                                                                                                                                                                                                                    /** * Detect collision between two bodies
                                                                                                                                                                                                                    using the Separating Axis Theorem. * @deprecated
                                                                                                                                                                                                                    replaced by Collision.collides * @method
                                                                                                                                                                                                                    collides * @param {body} bodyA * @param
                                                                                                                                                                                                                    {body} bodyB * @return {collision} collision
                                                                                                                                                                                                                    */ i.collides=function(e,t){return o.collides(e,t)};a(i,"collides","SAT.collides
                                                                                                                                                                                                                    âž¤ replaced by Collision.collides")})()},function(e,t,n){var
                                                                                                                                                                                                                    i={};e.exports=i;n(1);var o=n(0);(function(){
                                                                                                                                                                                                                    /** * Converts an SVG path into an array
                                                                                                                                                                                                                    of vector points. * If the input path forms
                                                                                                                                                                                                                    a concave shape, you must decompose the
                                                                                                                                                                                                                    result into convex parts before use. *
                                                                                                                                                                                                                    See `Bodies.fromVertices` which provides
                                                                                                                                                                                                                    support for this. * Note that this function
                                                                                                                                                                                                                    is not guaranteed to support complex paths
                                                                                                                                                                                                                    (such as those with holes). * You must
                                                                                                                                                                                                                    load the `pathseg.js` polyfill on newer
                                                                                                                                                                                                                    browsers. * @method pathToVertices * @param
                                                                                                                                                                                                                    {SVGPathElement} path * @param {Number}
                                                                                                                                                                                                                    [sampleLength=15] * @return {Vector[]}
                                                                                                                                                                                                                    points */ i.pathToVertices=function(e,t){"undefined"===typeof
                                                                                                                                                                                                                    window||"SVGPathSeg"in window||o.warn("Svg.pathToVertices:
                                                                                                                                                                                                                    SVGPathSeg not defined, a polyfill is required.");var
                                                                                                                                                                                                                    n,r,a,s,l,c,u,f,d,p,v,y,m=[],g=0,x=0,h=0;t=t||15;var
                                                                                                                                                                                                                    addPoint=function(e,t,n){var i=n%2===1&&n>1;if(!d||e!=d.x||t!=d.y){if(d&&i){v=d.x;y=d.y}else{v=0;y=0}var
                                                                                                                                                                                                                    o={x:v+e,y:y+t};!i&&d||(d=o);m.push(o);x=v+e;h=y+t}};var
                                                                                                                                                                                                                    addSegmentPoint=function(e){var t=e.pathSegTypeAsLetter.toUpperCase();if("Z"!==t){switch(t){case"M":case"L":case"T":case"C":case"S":case"Q":x=e.x;h=e.y;break;case"H":x=e.x;break;case"V":h=e.y;break}addPoint(x,h,e.pathSegType)}};i._svgPathToAbsolute(e);a=e.getTotalLength();c=[];for(n=0;n
                                                                                                                                                                                                                    <e.pathSegList.numberOfItems;n+=1)c.push(e.pathSegList.getItem(n));u=c.concat();while(g<a){p=e.getPathSegAtLength(g);l=c[p];if(l!=f){while(u.length&&u[0]!=l)addSegmentPoint(u.shift());f=l}switch(l.pathSegTypeAsLetter.toUpperCase()){case
                                                                                                                                                                                                                        "C":case "T":case "S":case "Q":case "A":s=e.getPointAtLength(g);addPoint(s.x,s.y,0);break}g+=t}for(n=0,r=u.length;n<r;++n)addSegmentPoint(u[n]);return
                                                                                                                                                                                                                        m};i._svgPathToAbsolute=function(e){var
                                                                                                                                                                                                                        t,n,i,o,r,a,s=e.pathSegList,l=0,c=0,u=s.numberOfItems;for(var
                                                                                                                                                                                                                        f=0;f<u;++f){var d=s.getItem(f),p=d.pathSegTypeAsLetter;if(/[MLHVCSQTA]/.test(p)){
                                                                                                                                                                                                                        "x"in d&&(l=d.x); "y"in d&&(c=d.y)}else{
                                                                                                                                                                                                                        "x1"in d&&(i=l+d.x1); "x2"in d&&(r=l+d.x2);
                                                                                                                                                                                                                        "y1"in d&&(o=c+d.y1); "y2"in d&&(a=c+d.y2);
                                                                                                                                                                                                                        "x"in d&&(l+=d.x); "y"in d&&(c+=d.y);switch(p){case
                                                                                                                                                                                                                        "m":s.replaceItem(e.createSVGPathSegMovetoAbs(l,c),f);break;case
                                                                                                                                                                                                                        "l":s.replaceItem(e.createSVGPathSegLinetoAbs(l,c),f);break;case
                                                                                                                                                                                                                        "h":s.replaceItem(e.createSVGPathSegLinetoHorizontalAbs(l),f);break;case
                                                                                                                                                                                                                        "v":s.replaceItem(e.createSVGPathSegLinetoVerticalAbs(c),f);break;case
                                                                                                                                                                                                                        "c":s.replaceItem(e.createSVGPathSegCurvetoCubicAbs(l,c,i,o,r,a),f);break;case
                                                                                                                                                                                                                        "s":s.replaceItem(e.createSVGPathSegCurvetoCubicSmoothAbs(l,c,r,a),f);break;case
                                                                                                                                                                                                                        "q":s.replaceItem(e.createSVGPathSegCurvetoQuadraticAbs(l,c,i,o),f);break;case
                                                                                                                                                                                                                        "t":s.replaceItem(e.createSVGPathSegCurvetoQuadraticSmoothAbs(l,c),f);break;case
                                                                                                                                                                                                                        "a":s.replaceItem(e.createSVGPathSegArcAbs(l,c,d.r1,d.r2,d.angle,d.largeArcFlag,d.sweepFlag),f);break;case
                                                                                                                                                                                                                        "z":case "Z":l=t;c=n;break}}if( "M"==p||
                                                                                                                                                                                                                        "m"==p){t=l;n=c}}}})()},function(e,t,n){var
                                                                                                                                                                                                                        i={};e.exports=i;var o=n(5);n(0);(function(){i.create=o.create;i.add=o.add;i.remove=o.remove;i.clear=o.clear;i.addComposite=o.addComposite;i.addBody=o.addBody;i.addConstraint=o.addConstraint})()}])}));var
                                                                                                                                                                                                                        n=t;const i=t.Matter,o=t.__esModule;export{i
                                                                                                                                                                                                                        as Matter,o as __esModule,n as default};
                                                                                                                                                                                                                    //# sourceMappingURL=matter.js.map